{"meta":{"title":"I'm Long","subtitle":null,"description":"Fuck The Code World...","author":"nix.long","url":"https://nixlong.github.io"},"pages":[{"title":"","date":"2017-08-15T14:54:13.031Z","updated":"2017-08-15T14:54:13.031Z","comments":true,"path":"404.html","permalink":"https://nixlong.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2017-08-15T05:11:56.000Z","updated":"2017-08-15T05:15:27.372Z","comments":false,"path":"categories/index.html","permalink":"https://nixlong.github.io/categories/index.html","excerpt":"","text":""},{"title":"TagCloud","date":"2017-08-15T05:02:10.000Z","updated":"2017-08-15T05:03:04.765Z","comments":false,"path":"tags/index.html","permalink":"https://nixlong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"UCOSIII-v3.04.05 定时器Bug","slug":"04-Mcu/[mcu] - UCOSIII-3.04.05定时器Bug","date":"2017-10-26T10:00:00.000Z","updated":"2017-10-31T06:38:34.625Z","comments":true,"path":"2017/10/26/04-Mcu/[mcu] - UCOSIII-3.04.05定时器Bug/","link":"","permalink":"https://nixlong.github.io/2017/10/26/04-Mcu/[mcu] - UCOSIII-3.04.05定时器Bug/","excerpt":"#UCOSIII-v3.04.05 定时器Bug [TOC] 0. 异常发生移植Dthing 到UCOSIII-v3.04.05, 使用UCOS定时器作为调度时标支持. 涉及到定时器接口: 123456789void OSTmrCreate (OS_TMR *p_tmr, CPU_CHAR *p_name, OS_TICK dly, OS_TICK period, OS_OPT opt, OS_TMR_CALLBACK_PTR p_callback, void *p_callback_arg, OS_ERR *p_err) 12CPU_BOOLEAN OSTmrStart (OS_TMR *p_tmr, OS_ERR *p_err) 1234CPU_BOOLEAN OSTmrStop (OS_TMR *p_tmr, OS_OPT opt, void *p_callback_arg, OS_ERR *p_err) 创建定时器示意代码: 周期性定时器 无delay 周期性时间为若干毫秒 12345678910111213&#123; OS_TMR * tmr = NULL; OS_OPT opt = OS_OPT_TMR_PERIODIC; OS_TICK dly = 0; OS_ERR err; tmr = malloc(sizeof(OS_TMR)); if(tmr == NULL)&#123; //handle exception return; &#125; OSTmrCreate(tmr, &quot;name&quot;, dly, period_ms, opt, callback, NULL, &amp;err); 然后启动定时器在各种状态下进行Debug Start/Stop, 然后奇怪的事情发生了: 有时出现等待很久, 定时器都没有超时回调callback的情况","text":"#UCOSIII-v3.04.05 定时器Bug [TOC] 0. 异常发生移植Dthing 到UCOSIII-v3.04.05, 使用UCOS定时器作为调度时标支持. 涉及到定时器接口: 123456789void OSTmrCreate (OS_TMR *p_tmr, CPU_CHAR *p_name, OS_TICK dly, OS_TICK period, OS_OPT opt, OS_TMR_CALLBACK_PTR p_callback, void *p_callback_arg, OS_ERR *p_err) 12CPU_BOOLEAN OSTmrStart (OS_TMR *p_tmr, OS_ERR *p_err) 1234CPU_BOOLEAN OSTmrStop (OS_TMR *p_tmr, OS_OPT opt, void *p_callback_arg, OS_ERR *p_err) 创建定时器示意代码: 周期性定时器 无delay 周期性时间为若干毫秒 12345678910111213&#123; OS_TMR * tmr = NULL; OS_OPT opt = OS_OPT_TMR_PERIODIC; OS_TICK dly = 0; OS_ERR err; tmr = malloc(sizeof(OS_TMR)); if(tmr == NULL)&#123; //handle exception return; &#125; OSTmrCreate(tmr, &quot;name&quot;, dly, period_ms, opt, callback, NULL, &amp;err); 然后启动定时器在各种状态下进行Debug Start/Stop, 然后奇怪的事情发生了: 有时出现等待很久, 定时器都没有超时回调callback的情况 1. 原因在哪?反复检查参数设置, 阅读各API使用说明, 均未发现接口使用方面的异常, 相关Dthing定时器逻辑层代码在其他操作系统, 诸如win/threadx都能正常的超时响应. 是ucos-iii定时器存在BUG? 顺着这个猜想开始阅读ucos-iii timer源码. ###1.1 Timer的状态转换 create时, 状态设置为OS_TMR_STATE_STOPPED: 1p_tmr-&gt;State = (OS_STATE )OS_TMR_STATE_STOPPED; /* Initialize the timer fields */ ​ 首次start成功后,状态切换到 OS_TMR_STATE_RUNNING: 123456789101112131415161718192021222324 case OS_TMR_STATE_STOPPED: /* Start the timer */ case OS_TMR_STATE_COMPLETED: p_tmr-&gt;State = OS_TMR_STATE_RUNNING;if (p_tmr-&gt;Dly == (OS_TICK)0) &#123; p_tmr-&gt;Remain = p_tmr-&gt;Period;&#125; else &#123; p_tmr-&gt;Remain = p_tmr-&gt;Dly; &#125; if (OSTmrListPtr == (OS_TMR *)0) &#123; /* Link into timer list */ p_tmr-&gt;NextPtr = (OS_TMR *)0; /* This is the first timer in the list */ p_tmr-&gt;PrevPtr = (OS_TMR *)0; OSTmrListPtr = p_tmr; OSTmrListEntries = 1u; &#125; else &#123; p_next = OSTmrListPtr; /* Insert at the beginning of the list */ p_tmr-&gt;NextPtr = OSTmrListPtr; p_tmr-&gt;PrevPtr = (OS_TMR *)0; p_next-&gt;PrevPtr = p_tmr; OSTmrListPtr = p_tmr; OSTmrListEntries++; &#125; *p_err = OS_ERR_NONE; success = DEF_TRUE; break; 再看timer的任务核心逻辑部分: 1234567891011121314p_tmr-&gt;Remain--; if (p_tmr-&gt;Remain == 0) &#123; if (p_tmr-&gt;Opt == OS_OPT_TMR_PERIODIC) &#123; p_tmr-&gt;Remain = p_tmr-&gt;Period; /* Reload the time remaining */ &#125; else &#123; OS_TmrUnlink(p_tmr); /* Remove from list */ p_tmr-&gt;State = OS_TMR_STATE_COMPLETED; /* Indicate that the timer has completed */ &#125; p_fnct = p_tmr-&gt;CallbackPtr; /* Execute callback function if available */ if (p_fnct != (OS_TMR_CALLBACK_PTR)0) &#123; (*p_fnct)((void *)p_tmr, p_tmr-&gt;CallbackPtrArg); &#125; &#125; p_tmr-&gt;Remain先–, 再判断如果到0且为周期性定时器, 再次装载计时时间间隔,然后调用回调; 如果到0且是一次性定时器, 就切换到OS_TMR_STATE_COMPLETED状态. 看到这里知道, 定时器超时是通过p_tmr-&gt;Remain变量判断的, 再查p_tmr-&gt;Remain的赋值地方 关注点回到OSTmrStart: 1234567891011121314151617... switch (p_tmr-&gt;State) &#123; case OS_TMR_STATE_RUNNING: /* Restart the timer */ p_tmr-&gt;Remain = p_tmr-&gt;Dly; *p_err = OS_ERR_NONE; success = DEF_TRUE; break; case OS_TMR_STATE_STOPPED: /* Start the timer */ case OS_TMR_STATE_COMPLETED: p_tmr-&gt;State = OS_TMR_STATE_RUNNING; if (p_tmr-&gt;Dly == (OS_TICK)0) &#123; p_tmr-&gt;Remain = p_tmr-&gt;Period; &#125; else &#123; p_tmr-&gt;Remain = p_tmr-&gt;Dly; &#125;... ​ 终于柳暗花明, p_tmr-&gt;Remain在不同的定时策略下，初值来自p_tmr-&gt;Period或者p_tmr-&gt;Dly. ​ 注意 case OS_TMR_STATE_RUNNING: 条件和’case OS_TMR_STATE_STOPPED’ 不一致的地方, 再快速联想到: ​ 1) 使用时dly初值为0 ​ 2) typedef CPU_INT32U OS_TICK; ​ 3) 定时器任务是Remain先– 再与0判断 1.2 真相终于浮出水面​ 如果定时器还在运行状态,再次Start了定时器, Remain的初值是直接装载的delay值,而我们设置的delay值为0,这种条件下Remain的值就变为0. 定时器任务又是先对Remian做的自减后再与0对比，实际这时类型为u32的Remain–已经后已经溢出为0xFFFFFFFF. ​ 等待这么大的TICK超时, 太久了…. ​ 至此,确认这个BUG源自UCOS 3.04.05的Timer本身 2.解决方案找到原因后的解决方案是极为容易的, 在 OS_TMR_STATE_RUNNING 状态下采用和 ‘OS_TMR_STATE_STOPPED’ 状态相同的Remain赋值逻辑即可: 123456789101112131415161718192021... switch (p_tmr-&gt;State) &#123; case OS_TMR_STATE_RUNNING: /* Restart the timer */ if (p_tmr-&gt;Dly == (OS_TICK)0) &#123; p_tmr-&gt;Remain = p_tmr-&gt;Period; &#125; else &#123; p_tmr-&gt;Remain = p_tmr-&gt;Dly; &#125; *p_err = OS_ERR_NONE; success = DEF_TRUE; break; case OS_TMR_STATE_STOPPED: /* Start the timer */ case OS_TMR_STATE_COMPLETED: p_tmr-&gt;State = OS_TMR_STATE_RUNNING; if (p_tmr-&gt;Dly == (OS_TICK)0) &#123; p_tmr-&gt;Remain = p_tmr-&gt;Period; &#125; else &#123; p_tmr-&gt;Remain = p_tmr-&gt;Dly; &#125;... ​ 不用担心Period和Delay都会为0再次造成Remain–溢出, 因为都为0在创建定时器的时候已经返回错误了 3.新版本还有bug吗​ 通过Review UCOS-III 3.04.05定时器源码找到了这个定时器bug并解决, 那最新版本的ucos-iii还存在这个bug吗? 于是翻阅了v3.06.x的定时器源码: 1234567891011121314151617181920...case OS_TMR_STATE_RUNNING: /* Restart the timer */ if (p_tmr-&gt;Dly == 0u) &#123; p_tmr-&gt;Remain = p_tmr-&gt;Period; &#125; else &#123; p_tmr-&gt;Remain = p_tmr-&gt;Dly; &#125; *p_err = OS_ERR_NONE; success = DEF_TRUE; break; case OS_TMR_STATE_STOPPED: /* Start the timer */ case OS_TMR_STATE_COMPLETED: p_tmr-&gt;State = OS_TMR_STATE_RUNNING; if (p_tmr-&gt;Dly == 0u) &#123; p_tmr-&gt;Remain = p_tmr-&gt;Period; &#125; else &#123; p_tmr-&gt;Remain = p_tmr-&gt;Dly; &#125;... ​ 很显然的, ucos-iii官方已经测试到并使用相同的方法解决掉这个bug了.任然不死心, 去官方网站寻找这个bug从哪个版本解决的, 在 UCOS-III Release note 找到: 12345678Version 3.06.00Releasedate :2016-06-30...Bug fixes...When resetting a periodic timer with 0 initialdelay, the timer is now reset to the period value rather than the initial delay.... ​ 于2016.06.30 在3.06.00版本fix. 另外还看到其他特性/bug的修改,看来需要升级UCOS-III的版本了…","categories":[{"name":"MCU","slug":"MCU","permalink":"https://nixlong.github.io/categories/MCU/"}],"tags":[{"name":"ucosiii","slug":"ucosiii","permalink":"https://nixlong.github.io/tags/ucosiii/"},{"name":"timer","slug":"timer","permalink":"https://nixlong.github.io/tags/timer/"}]},{"title":"VM学习资料整理","slug":"02-Vm/[vm] - VM学习工具和资料整理","date":"2017-10-25T04:00:00.000Z","updated":"2017-10-31T06:38:34.609Z","comments":true,"path":"2017/10/25/02-Vm/[vm] - VM学习工具和资料整理/","link":"","permalink":"https://nixlong.github.io/2017/10/25/02-Vm/[vm] - VM学习工具和资料整理/","excerpt":"","text":"VM学习资料整理[TOC] 资料篇 构建OpenJDK (Gitbook) OpenJdk源码剖析 (Blogs) OpenJDK源码","categories":[{"name":"VM","slug":"VM","permalink":"https://nixlong.github.io/categories/VM/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://nixlong.github.io/tags/jvm/"},{"name":"vm","slug":"vm","permalink":"https://nixlong.github.io/tags/vm/"}]},{"title":"Dalvik反编译","slug":"02-Vm/[vm] - Dalvik反编译","date":"2017-10-20T04:02:00.000Z","updated":"2017-10-31T06:38:34.593Z","comments":true,"path":"2017/10/20/02-Vm/[vm] - Dalvik反编译/","link":"","permalink":"https://nixlong.github.io/2017/10/20/02-Vm/[vm] - Dalvik反编译/","excerpt":"Dalvik反编译[TOC] 1.[注意]不要使用JDK1.8及以上2.[流程].java -&gt; .class -&gt; .dex –&gt; .smali ##0. Demo 1234567public class Main&#123; void main(String args[])&#123; int i = 0; i = 5; return; &#125;&#125; 1.javac编译 .class javac Main.java 2.生成Dex使用Android dx.jar包将.class转换为.dex, dx.jar一般位于 android-sdk\\build-tools* 下面 java -jar dx.jar –dex –output=Main.dex Main.class 3. Samli使用smali包工具将dex文件转换为smali：java -jar baksmali.jar Main.dex 此时会生成一个out目录，在out目录下的Main.smali就是我们要看到的smali代码了 12345678910111213141516171819.class public LMain;.super Ljava/lang/Object;.source \"Main.java\"# direct methods.method public constructor &lt;init&gt;()V .registers 1 .prologue .line 2 invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void.end method# virtual methods.method main([Ljava/lang/String;)V .registers 2 .prologue .line 5 .line 7 return-void.end method","text":"Dalvik反编译[TOC] 1.[注意]不要使用JDK1.8及以上2.[流程].java -&gt; .class -&gt; .dex –&gt; .smali ##0. Demo 1234567public class Main&#123; void main(String args[])&#123; int i = 0; i = 5; return; &#125;&#125; 1.javac编译 .class javac Main.java 2.生成Dex使用Android dx.jar包将.class转换为.dex, dx.jar一般位于 android-sdk\\build-tools* 下面 java -jar dx.jar –dex –output=Main.dex Main.class 3. Samli使用smali包工具将dex文件转换为smali：java -jar baksmali.jar Main.dex 此时会生成一个out目录，在out目录下的Main.smali就是我们要看到的smali代码了 12345678910111213141516171819.class public LMain;.super Ljava/lang/Object;.source \"Main.java\"# direct methods.method public constructor &lt;init&gt;()V .registers 1 .prologue .line 2 invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void.end method# virtual methods.method main([Ljava/lang/String;)V .registers 2 .prologue .line 5 .line 7 return-void.end method 4. 涉及工具 apktool：是apk格式文件与smali文件的转换 dex2jar：是dex格式文件与jar文件的转换 smali/baksmali：是dex格式文件与smali文件的转换 5. Bat脚本 java2smali.bat 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556REM =====================================================================REM Author: nix.longREM Date: 2017.10.17REM Function: compile x.java to dalvik smali code REM =====================================================================@echo offif \"%1\"==\"\" ( goto help)set input=%1set baksmali=baksmali-2.1.3.jarIF %input% == help ( goto help) ELSE IF %input% == clean ( IF EXIST *.class ( del /f /s /q *.class ) IF EXIST *.dex ( del /f /s /q *.dex ) IF EXIST *.smali ( del /f /s /q *.smali )) ELSE ( IF EXIST %input%.class ( del /f /s /q %input%.class ) IF EXIST %input%.dex ( del /f /s /q %input%.dex ) IF EXIST %input%/%input%.smali ( del /f /s /q %input%\\%input%.smali ) echo 'to make:' %input%.java echo 'to gen class:' %input%.class javac %input%.java echo 'to gen dex:' %input%.dex java -jar dx.jar --dex --output=%input%.dex %input%.class java -jar %baksmali% -o %input% %input%.dex echo 'gen smali ok...')goto end:help echo ----------------------------------------------------------------- echo help [dalvik smali]: echo java2smali.bat help - show help echo java2smali.bat clean - clean mid-files echo java2smali.bat X - gen smali file for X.java echo -----------------------------------------------------------------:end","categories":[{"name":"VM","slug":"VM","permalink":"https://nixlong.github.io/categories/VM/"}],"tags":[{"name":"dalvik","slug":"dalvik","permalink":"https://nixlong.github.io/tags/dalvik/"}]},{"title":"JVM反编译","slug":"02-Vm/[vm] - JVM反编译","date":"2017-10-20T04:00:00.000Z","updated":"2017-10-31T06:38:34.609Z","comments":true,"path":"2017/10/20/02-Vm/[vm] - JVM反编译/","link":"","permalink":"https://nixlong.github.io/2017/10/20/02-Vm/[vm] - JVM反编译/","excerpt":"JVM反编译[TOC] 1. Code Demo[java] 示例demo, 保存为Main.java 12345678package com.test.Main;public class Main&#123; void main(String args[])&#123; int i = 0; i = 5; return; &#125;&#125; 2.javacjavac Main.java 生成 Main.class javac Main.java 3.javap使用javap命令反编译class文件，查看助记符指令 javap -c -v Main.class","text":"JVM反编译[TOC] 1. Code Demo[java] 示例demo, 保存为Main.java 12345678package com.test.Main;public class Main&#123; void main(String args[])&#123; int i = 0; i = 5; return; &#125;&#125; 2.javacjavac Main.java 生成 Main.class javac Main.java 3.javap使用javap命令反编译class文件，查看助记符指令 javap -c -v Main.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Classfile /G:/Mess/test/Main.class Last modified 2017-10-16; size 279 bytes MD5 checksum a8b7efbdef220ee87f1d79cd549cf26c Compiled from \"Main.java\"public class com.test.Main.Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #3.#12 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Class #13 // com/test/Main/Main #3 = Class #14 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 main #9 = Utf8 ([Ljava/lang/String;)V #10 = Utf8 SourceFile #11 = Utf8 Main.java #12 = NameAndType #4:#5 // \"&lt;init&gt;\":()V #13 = Utf8 com/test/Main/Main #14 = Utf8 java/lang/Object&#123; public com.test.Main.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 3: 0 void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: Code: stack=1, locals=3, args_size=2 0: iconst_0 1: istore_2 2: iconst_5 3: istore_2 4: return LineNumberTable: line 6: 0 line 7: 2 line 8: 4&#125;SourceFile: \"Main.java\" 其中, javap用法: javap 12345678910111213141516171819用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置 4.Bat脚本 java2opcode.bat 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354REM =====================================================================REM Author: nix.longREM Date: 2017.10.17REM Function: compile x.java to jvm byte-code REM =====================================================================@echo offif \"%1\"==\"\" ( goto help)set input=%1%IF %input% == help ( goto help) ELSE IF %input% == clean ( IF EXIST *.class ( del /f /s /q *.class ) IF EXIST *.dex ( del /f /s /q *.dex )) ELSE ( IF EXIST %input%.class ( del /f /s /q %input%.class ) IF EXIST %input%.dex ( del /f /s /q %input%.dex ) echo 'to make:' %input%.java echo 'to gen class:' %input%.class javac %input%.java echo 'to show opcode:' echo ----------------------------------------------------------------- echo= echo= echo= javap -v -p -s %input%.class echo= echo= echo= echo -----------------------------------------------------------------)goto end:help echo ----------------------------------------------------------------- echo help [JVM Bytecode]: echo java2opcode.bat help - show help echo java2opcode.bat clean - clean mid-files echo java2opcode.bat X - gen bytecode for X.java echo -----------------------------------------------------------------:end","categories":[{"name":"VM","slug":"VM","permalink":"https://nixlong.github.io/categories/VM/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://nixlong.github.io/tags/jvm/"},{"name":"vm","slug":"vm","permalink":"https://nixlong.github.io/tags/vm/"}]},{"title":"理解Dalvik指令码执行原理","slug":"02-Vm/[vm] - 理解Dalvik指令码执行原理","date":"2017-10-19T04:00:00.000Z","updated":"2017-10-31T06:38:34.609Z","comments":true,"path":"2017/10/19/02-Vm/[vm] - 理解Dalvik指令码执行原理/","link":"","permalink":"https://nixlong.github.io/2017/10/19/02-Vm/[vm] - 理解Dalvik指令码执行原理/","excerpt":"[VM]理解Dalvik指令码执行原理[TOC] 0. Android 源文档Android 在源码4.0的docs目录下，提供了3篇文档: 1) .dex — Dalvik Executable Format - 描述了Dex文件格式2) Bytecode for the Dalvik VM - 描述了Dalvik的字节码指令集3) Dalvik VM Instruction Formats - 描述了Dalvik的指令格式 1. 弄懂Dex文件格式这块网上有较好的介绍, 比如: 彻底弄懂dalvik字节码【一】彻底弄懂dalvik字节码【二】彻底弄懂dalvik字节码【三】Android安全–Dex文件格式详解一篇文章带你搞懂DEX文件的结构 2.弄懂Dalvik指令格式参考: Dalvik指令格式 3.读懂指令码 一条完整的Dalvik指令是变长的。Dalvik的指令语义需要由[指令操作码]和[指令格式]共同才能确定，而沟通[指令操作码]和[指令格式]的纽带, 叫做[指令格式标识]. 3.1 指令操作码在Android 4.0 的Dalvik中，定义了如下指令操作码:","text":"[VM]理解Dalvik指令码执行原理[TOC] 0. Android 源文档Android 在源码4.0的docs目录下，提供了3篇文档: 1) .dex — Dalvik Executable Format - 描述了Dex文件格式2) Bytecode for the Dalvik VM - 描述了Dalvik的字节码指令集3) Dalvik VM Instruction Formats - 描述了Dalvik的指令格式 1. 弄懂Dex文件格式这块网上有较好的介绍, 比如: 彻底弄懂dalvik字节码【一】彻底弄懂dalvik字节码【二】彻底弄懂dalvik字节码【三】Android安全–Dex文件格式详解一篇文章带你搞懂DEX文件的结构 2.弄懂Dalvik指令格式参考: Dalvik指令格式 3.读懂指令码 一条完整的Dalvik指令是变长的。Dalvik的指令语义需要由[指令操作码]和[指令格式]共同才能确定，而沟通[指令操作码]和[指令格式]的纽带, 叫做[指令格式标识]. 3.1 指令操作码在Android 4.0 的Dalvik中，定义了如下指令操作码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516typedef enum &#123; // BEGIN(libdex-opcode-enum); GENERATED AUTOMATICALLY BY opcode-gen OP_NOP = 0x00, OP_MOVE = 0x01, OP_MOVE_FROM16 = 0x02, OP_MOVE_16 = 0x03, OP_MOVE_WIDE = 0x04, OP_MOVE_WIDE_FROM16 = 0x05, OP_MOVE_WIDE_16 = 0x06, OP_MOVE_OBJECT = 0x07, OP_MOVE_OBJECT_FROM16 = 0x08, OP_MOVE_OBJECT_16 = 0x09, OP_MOVE_RESULT = 0x0a, OP_MOVE_RESULT_WIDE = 0x0b, OP_MOVE_RESULT_OBJECT = 0x0c, OP_MOVE_EXCEPTION = 0x0d, OP_RETURN_VOID = 0x0e, OP_RETURN = 0x0f, OP_RETURN_WIDE = 0x10, OP_RETURN_OBJECT = 0x11, OP_CONST_4 = 0x12, OP_CONST_16 = 0x13, OP_CONST = 0x14, OP_CONST_HIGH16 = 0x15, OP_CONST_WIDE_16 = 0x16, OP_CONST_WIDE_32 = 0x17, OP_CONST_WIDE = 0x18, OP_CONST_WIDE_HIGH16 = 0x19, OP_CONST_STRING = 0x1a, OP_CONST_STRING_JUMBO = 0x1b, OP_CONST_CLASS = 0x1c, OP_MONITOR_ENTER = 0x1d, OP_MONITOR_EXIT = 0x1e, OP_CHECK_CAST = 0x1f, OP_INSTANCE_OF = 0x20, OP_ARRAY_LENGTH = 0x21, OP_NEW_INSTANCE = 0x22, OP_NEW_ARRAY = 0x23, OP_FILLED_NEW_ARRAY = 0x24, OP_FILLED_NEW_ARRAY_RANGE = 0x25, OP_FILL_ARRAY_DATA = 0x26, OP_THROW = 0x27, OP_GOTO = 0x28, OP_GOTO_16 = 0x29, OP_GOTO_32 = 0x2a, OP_PACKED_SWITCH = 0x2b, OP_SPARSE_SWITCH = 0x2c, OP_CMPL_FLOAT = 0x2d, OP_CMPG_FLOAT = 0x2e, OP_CMPL_DOUBLE = 0x2f, OP_CMPG_DOUBLE = 0x30, OP_CMP_LONG = 0x31, OP_IF_EQ = 0x32, OP_IF_NE = 0x33, OP_IF_LT = 0x34, OP_IF_GE = 0x35, OP_IF_GT = 0x36, OP_IF_LE = 0x37, OP_IF_EQZ = 0x38, OP_IF_NEZ = 0x39, OP_IF_LTZ = 0x3a, OP_IF_GEZ = 0x3b, OP_IF_GTZ = 0x3c, OP_IF_LEZ = 0x3d, OP_UNUSED_3E = 0x3e, OP_UNUSED_3F = 0x3f, OP_UNUSED_40 = 0x40, OP_UNUSED_41 = 0x41, OP_UNUSED_42 = 0x42, OP_UNUSED_43 = 0x43, OP_AGET = 0x44, OP_AGET_WIDE = 0x45, OP_AGET_OBJECT = 0x46, OP_AGET_BOOLEAN = 0x47, OP_AGET_BYTE = 0x48, OP_AGET_CHAR = 0x49, OP_AGET_SHORT = 0x4a, OP_APUT = 0x4b, OP_APUT_WIDE = 0x4c, OP_APUT_OBJECT = 0x4d, OP_APUT_BOOLEAN = 0x4e, OP_APUT_BYTE = 0x4f, OP_APUT_CHAR = 0x50, OP_APUT_SHORT = 0x51, OP_IGET = 0x52, OP_IGET_WIDE = 0x53, OP_IGET_OBJECT = 0x54, OP_IGET_BOOLEAN = 0x55, OP_IGET_BYTE = 0x56, OP_IGET_CHAR = 0x57, OP_IGET_SHORT = 0x58, OP_IPUT = 0x59, OP_IPUT_WIDE = 0x5a, OP_IPUT_OBJECT = 0x5b, OP_IPUT_BOOLEAN = 0x5c, OP_IPUT_BYTE = 0x5d, OP_IPUT_CHAR = 0x5e, OP_IPUT_SHORT = 0x5f, OP_SGET = 0x60, OP_SGET_WIDE = 0x61, OP_SGET_OBJECT = 0x62, OP_SGET_BOOLEAN = 0x63, OP_SGET_BYTE = 0x64, OP_SGET_CHAR = 0x65, OP_SGET_SHORT = 0x66, OP_SPUT = 0x67, OP_SPUT_WIDE = 0x68, OP_SPUT_OBJECT = 0x69, OP_SPUT_BOOLEAN = 0x6a, OP_SPUT_BYTE = 0x6b, OP_SPUT_CHAR = 0x6c, OP_SPUT_SHORT = 0x6d, OP_INVOKE_VIRTUAL = 0x6e, OP_INVOKE_SUPER = 0x6f, OP_INVOKE_DIRECT = 0x70, OP_INVOKE_STATIC = 0x71, OP_INVOKE_INTERFACE = 0x72, OP_UNUSED_73 = 0x73, OP_INVOKE_VIRTUAL_RANGE = 0x74, OP_INVOKE_SUPER_RANGE = 0x75, OP_INVOKE_DIRECT_RANGE = 0x76, OP_INVOKE_STATIC_RANGE = 0x77, OP_INVOKE_INTERFACE_RANGE = 0x78, OP_UNUSED_79 = 0x79, OP_UNUSED_7A = 0x7a, OP_NEG_INT = 0x7b, OP_NOT_INT = 0x7c, OP_NEG_LONG = 0x7d, OP_NOT_LONG = 0x7e, OP_NEG_FLOAT = 0x7f, OP_NEG_DOUBLE = 0x80, OP_INT_TO_LONG = 0x81, OP_INT_TO_FLOAT = 0x82, OP_INT_TO_DOUBLE = 0x83, OP_LONG_TO_INT = 0x84, OP_LONG_TO_FLOAT = 0x85, OP_LONG_TO_DOUBLE = 0x86, OP_FLOAT_TO_INT = 0x87, OP_FLOAT_TO_LONG = 0x88, OP_FLOAT_TO_DOUBLE = 0x89, OP_DOUBLE_TO_INT = 0x8a, OP_DOUBLE_TO_LONG = 0x8b, OP_DOUBLE_TO_FLOAT = 0x8c, OP_INT_TO_BYTE = 0x8d, OP_INT_TO_CHAR = 0x8e, OP_INT_TO_SHORT = 0x8f, OP_ADD_INT = 0x90, OP_SUB_INT = 0x91, OP_MUL_INT = 0x92, OP_DIV_INT = 0x93, OP_REM_INT = 0x94, OP_AND_INT = 0x95, OP_OR_INT = 0x96, OP_XOR_INT = 0x97, OP_SHL_INT = 0x98, OP_SHR_INT = 0x99, OP_USHR_INT = 0x9a, OP_ADD_LONG = 0x9b, OP_SUB_LONG = 0x9c, OP_MUL_LONG = 0x9d, OP_DIV_LONG = 0x9e, OP_REM_LONG = 0x9f, OP_AND_LONG = 0xa0, OP_OR_LONG = 0xa1, OP_XOR_LONG = 0xa2, OP_SHL_LONG = 0xa3, OP_SHR_LONG = 0xa4, OP_USHR_LONG = 0xa5, OP_ADD_FLOAT = 0xa6, OP_SUB_FLOAT = 0xa7, OP_MUL_FLOAT = 0xa8, OP_DIV_FLOAT = 0xa9, OP_REM_FLOAT = 0xaa, OP_ADD_DOUBLE = 0xab, OP_SUB_DOUBLE = 0xac, OP_MUL_DOUBLE = 0xad, OP_DIV_DOUBLE = 0xae, OP_REM_DOUBLE = 0xaf, OP_ADD_INT_2ADDR = 0xb0, OP_SUB_INT_2ADDR = 0xb1, OP_MUL_INT_2ADDR = 0xb2, OP_DIV_INT_2ADDR = 0xb3, OP_REM_INT_2ADDR = 0xb4, OP_AND_INT_2ADDR = 0xb5, OP_OR_INT_2ADDR = 0xb6, OP_XOR_INT_2ADDR = 0xb7, OP_SHL_INT_2ADDR = 0xb8, OP_SHR_INT_2ADDR = 0xb9, OP_USHR_INT_2ADDR = 0xba, OP_ADD_LONG_2ADDR = 0xbb, OP_SUB_LONG_2ADDR = 0xbc, OP_MUL_LONG_2ADDR = 0xbd, OP_DIV_LONG_2ADDR = 0xbe, OP_REM_LONG_2ADDR = 0xbf, OP_AND_LONG_2ADDR = 0xc0, OP_OR_LONG_2ADDR = 0xc1, OP_XOR_LONG_2ADDR = 0xc2, OP_SHL_LONG_2ADDR = 0xc3, OP_SHR_LONG_2ADDR = 0xc4, OP_USHR_LONG_2ADDR = 0xc5, OP_ADD_FLOAT_2ADDR = 0xc6, OP_SUB_FLOAT_2ADDR = 0xc7, OP_MUL_FLOAT_2ADDR = 0xc8, OP_DIV_FLOAT_2ADDR = 0xc9, OP_REM_FLOAT_2ADDR = 0xca, OP_ADD_DOUBLE_2ADDR = 0xcb, OP_SUB_DOUBLE_2ADDR = 0xcc, OP_MUL_DOUBLE_2ADDR = 0xcd, OP_DIV_DOUBLE_2ADDR = 0xce, OP_REM_DOUBLE_2ADDR = 0xcf, OP_ADD_INT_LIT16 = 0xd0, OP_RSUB_INT = 0xd1, OP_MUL_INT_LIT16 = 0xd2, OP_DIV_INT_LIT16 = 0xd3, OP_REM_INT_LIT16 = 0xd4, OP_AND_INT_LIT16 = 0xd5, OP_OR_INT_LIT16 = 0xd6, OP_XOR_INT_LIT16 = 0xd7, OP_ADD_INT_LIT8 = 0xd8, OP_RSUB_INT_LIT8 = 0xd9, OP_MUL_INT_LIT8 = 0xda, OP_DIV_INT_LIT8 = 0xdb, OP_REM_INT_LIT8 = 0xdc, OP_AND_INT_LIT8 = 0xdd, OP_OR_INT_LIT8 = 0xde, OP_XOR_INT_LIT8 = 0xdf, OP_SHL_INT_LIT8 = 0xe0, OP_SHR_INT_LIT8 = 0xe1, OP_USHR_INT_LIT8 = 0xe2, OP_IGET_VOLATILE = 0xe3, OP_IPUT_VOLATILE = 0xe4, OP_SGET_VOLATILE = 0xe5, OP_SPUT_VOLATILE = 0xe6, OP_IGET_OBJECT_VOLATILE = 0xe7, OP_IGET_WIDE_VOLATILE = 0xe8, OP_IPUT_WIDE_VOLATILE = 0xe9, OP_SGET_WIDE_VOLATILE = 0xea, OP_SPUT_WIDE_VOLATILE = 0xeb, OP_BREAKPOINT = 0xec, OP_THROW_VERIFICATION_ERROR = 0xed, OP_EXECUTE_INLINE = 0xee, OP_EXECUTE_INLINE_RANGE = 0xef, OP_INVOKE_OBJECT_INIT_RANGE = 0xf0, OP_RETURN_VOID_BARRIER = 0xf1, OP_IGET_QUICK = 0xf2, OP_IGET_WIDE_QUICK = 0xf3, OP_IGET_OBJECT_QUICK = 0xf4, OP_IPUT_QUICK = 0xf5, OP_IPUT_WIDE_QUICK = 0xf6, OP_IPUT_OBJECT_QUICK = 0xf7, OP_INVOKE_VIRTUAL_QUICK = 0xf8, OP_INVOKE_VIRTUAL_QUICK_RANGE = 0xf9, OP_INVOKE_SUPER_QUICK = 0xfa, OP_INVOKE_SUPER_QUICK_RANGE = 0xfb, OP_IPUT_OBJECT_VOLATILE = 0xfc, OP_SGET_OBJECT_VOLATILE = 0xfd, OP_SPUT_OBJECT_VOLATILE = 0xfe, OP_DISPATCH_FF = 0xff, OP_CONST_CLASS_JUMBO = 0x100, OP_CHECK_CAST_JUMBO = 0x101, OP_INSTANCE_OF_JUMBO = 0x102, OP_NEW_INSTANCE_JUMBO = 0x103, OP_NEW_ARRAY_JUMBO = 0x104, OP_FILLED_NEW_ARRAY_JUMBO = 0x105, OP_IGET_JUMBO = 0x106, OP_IGET_WIDE_JUMBO = 0x107, OP_IGET_OBJECT_JUMBO = 0x108, OP_IGET_BOOLEAN_JUMBO = 0x109, OP_IGET_BYTE_JUMBO = 0x10a, OP_IGET_CHAR_JUMBO = 0x10b, OP_IGET_SHORT_JUMBO = 0x10c, OP_IPUT_JUMBO = 0x10d, OP_IPUT_WIDE_JUMBO = 0x10e, OP_IPUT_OBJECT_JUMBO = 0x10f, OP_IPUT_BOOLEAN_JUMBO = 0x110, OP_IPUT_BYTE_JUMBO = 0x111, OP_IPUT_CHAR_JUMBO = 0x112, OP_IPUT_SHORT_JUMBO = 0x113, OP_SGET_JUMBO = 0x114, OP_SGET_WIDE_JUMBO = 0x115, OP_SGET_OBJECT_JUMBO = 0x116, OP_SGET_BOOLEAN_JUMBO = 0x117, OP_SGET_BYTE_JUMBO = 0x118, OP_SGET_CHAR_JUMBO = 0x119, OP_SGET_SHORT_JUMBO = 0x11a, OP_SPUT_JUMBO = 0x11b, OP_SPUT_WIDE_JUMBO = 0x11c, OP_SPUT_OBJECT_JUMBO = 0x11d, OP_SPUT_BOOLEAN_JUMBO = 0x11e, OP_SPUT_BYTE_JUMBO = 0x11f, OP_SPUT_CHAR_JUMBO = 0x120, OP_SPUT_SHORT_JUMBO = 0x121, OP_INVOKE_VIRTUAL_JUMBO = 0x122, OP_INVOKE_SUPER_JUMBO = 0x123, OP_INVOKE_DIRECT_JUMBO = 0x124, OP_INVOKE_STATIC_JUMBO = 0x125, OP_INVOKE_INTERFACE_JUMBO = 0x126, OP_UNUSED_27FF = 0x127, OP_UNUSED_28FF = 0x128, OP_UNUSED_29FF = 0x129, OP_UNUSED_2AFF = 0x12a, OP_UNUSED_2BFF = 0x12b, OP_UNUSED_2CFF = 0x12c, OP_UNUSED_2DFF = 0x12d, OP_UNUSED_2EFF = 0x12e, OP_UNUSED_2FFF = 0x12f, OP_UNUSED_30FF = 0x130, OP_UNUSED_31FF = 0x131, OP_UNUSED_32FF = 0x132, OP_UNUSED_33FF = 0x133, OP_UNUSED_34FF = 0x134, OP_UNUSED_35FF = 0x135, OP_UNUSED_36FF = 0x136, OP_UNUSED_37FF = 0x137, OP_UNUSED_38FF = 0x138, OP_UNUSED_39FF = 0x139, OP_UNUSED_3AFF = 0x13a, OP_UNUSED_3BFF = 0x13b, OP_UNUSED_3CFF = 0x13c, OP_UNUSED_3DFF = 0x13d, OP_UNUSED_3EFF = 0x13e, OP_UNUSED_3FFF = 0x13f, OP_UNUSED_40FF = 0x140, OP_UNUSED_41FF = 0x141, OP_UNUSED_42FF = 0x142, OP_UNUSED_43FF = 0x143, OP_UNUSED_44FF = 0x144, OP_UNUSED_45FF = 0x145, OP_UNUSED_46FF = 0x146, OP_UNUSED_47FF = 0x147, OP_UNUSED_48FF = 0x148, OP_UNUSED_49FF = 0x149, OP_UNUSED_4AFF = 0x14a, OP_UNUSED_4BFF = 0x14b, OP_UNUSED_4CFF = 0x14c, OP_UNUSED_4DFF = 0x14d, OP_UNUSED_4EFF = 0x14e, OP_UNUSED_4FFF = 0x14f, OP_UNUSED_50FF = 0x150, OP_UNUSED_51FF = 0x151, OP_UNUSED_52FF = 0x152, OP_UNUSED_53FF = 0x153, OP_UNUSED_54FF = 0x154, OP_UNUSED_55FF = 0x155, OP_UNUSED_56FF = 0x156, OP_UNUSED_57FF = 0x157, OP_UNUSED_58FF = 0x158, OP_UNUSED_59FF = 0x159, OP_UNUSED_5AFF = 0x15a, OP_UNUSED_5BFF = 0x15b, OP_UNUSED_5CFF = 0x15c, OP_UNUSED_5DFF = 0x15d, OP_UNUSED_5EFF = 0x15e, OP_UNUSED_5FFF = 0x15f, OP_UNUSED_60FF = 0x160, OP_UNUSED_61FF = 0x161, OP_UNUSED_62FF = 0x162, OP_UNUSED_63FF = 0x163, OP_UNUSED_64FF = 0x164, OP_UNUSED_65FF = 0x165, OP_UNUSED_66FF = 0x166, OP_UNUSED_67FF = 0x167, OP_UNUSED_68FF = 0x168, OP_UNUSED_69FF = 0x169, OP_UNUSED_6AFF = 0x16a, OP_UNUSED_6BFF = 0x16b, OP_UNUSED_6CFF = 0x16c, OP_UNUSED_6DFF = 0x16d, OP_UNUSED_6EFF = 0x16e, OP_UNUSED_6FFF = 0x16f, OP_UNUSED_70FF = 0x170, OP_UNUSED_71FF = 0x171, OP_UNUSED_72FF = 0x172, OP_UNUSED_73FF = 0x173, OP_UNUSED_74FF = 0x174, OP_UNUSED_75FF = 0x175, OP_UNUSED_76FF = 0x176, OP_UNUSED_77FF = 0x177, OP_UNUSED_78FF = 0x178, OP_UNUSED_79FF = 0x179, OP_UNUSED_7AFF = 0x17a, OP_UNUSED_7BFF = 0x17b, OP_UNUSED_7CFF = 0x17c, OP_UNUSED_7DFF = 0x17d, OP_UNUSED_7EFF = 0x17e, OP_UNUSED_7FFF = 0x17f, OP_UNUSED_80FF = 0x180, OP_UNUSED_81FF = 0x181, OP_UNUSED_82FF = 0x182, OP_UNUSED_83FF = 0x183, OP_UNUSED_84FF = 0x184, OP_UNUSED_85FF = 0x185, OP_UNUSED_86FF = 0x186, OP_UNUSED_87FF = 0x187, OP_UNUSED_88FF = 0x188, OP_UNUSED_89FF = 0x189, OP_UNUSED_8AFF = 0x18a, OP_UNUSED_8BFF = 0x18b, OP_UNUSED_8CFF = 0x18c, OP_UNUSED_8DFF = 0x18d, OP_UNUSED_8EFF = 0x18e, OP_UNUSED_8FFF = 0x18f, OP_UNUSED_90FF = 0x190, OP_UNUSED_91FF = 0x191, OP_UNUSED_92FF = 0x192, OP_UNUSED_93FF = 0x193, OP_UNUSED_94FF = 0x194, OP_UNUSED_95FF = 0x195, OP_UNUSED_96FF = 0x196, OP_UNUSED_97FF = 0x197, OP_UNUSED_98FF = 0x198, OP_UNUSED_99FF = 0x199, OP_UNUSED_9AFF = 0x19a, OP_UNUSED_9BFF = 0x19b, OP_UNUSED_9CFF = 0x19c, OP_UNUSED_9DFF = 0x19d, OP_UNUSED_9EFF = 0x19e, OP_UNUSED_9FFF = 0x19f, OP_UNUSED_A0FF = 0x1a0, OP_UNUSED_A1FF = 0x1a1, OP_UNUSED_A2FF = 0x1a2, OP_UNUSED_A3FF = 0x1a3, OP_UNUSED_A4FF = 0x1a4, OP_UNUSED_A5FF = 0x1a5, OP_UNUSED_A6FF = 0x1a6, OP_UNUSED_A7FF = 0x1a7, OP_UNUSED_A8FF = 0x1a8, OP_UNUSED_A9FF = 0x1a9, OP_UNUSED_AAFF = 0x1aa, OP_UNUSED_ABFF = 0x1ab, OP_UNUSED_ACFF = 0x1ac, OP_UNUSED_ADFF = 0x1ad, OP_UNUSED_AEFF = 0x1ae, OP_UNUSED_AFFF = 0x1af, OP_UNUSED_B0FF = 0x1b0, OP_UNUSED_B1FF = 0x1b1, OP_UNUSED_B2FF = 0x1b2, OP_UNUSED_B3FF = 0x1b3, OP_UNUSED_B4FF = 0x1b4, OP_UNUSED_B5FF = 0x1b5, OP_UNUSED_B6FF = 0x1b6, OP_UNUSED_B7FF = 0x1b7, OP_UNUSED_B8FF = 0x1b8, OP_UNUSED_B9FF = 0x1b9, OP_UNUSED_BAFF = 0x1ba, OP_UNUSED_BBFF = 0x1bb, OP_UNUSED_BCFF = 0x1bc, OP_UNUSED_BDFF = 0x1bd, OP_UNUSED_BEFF = 0x1be, OP_UNUSED_BFFF = 0x1bf, OP_UNUSED_C0FF = 0x1c0, OP_UNUSED_C1FF = 0x1c1, OP_UNUSED_C2FF = 0x1c2, OP_UNUSED_C3FF = 0x1c3, OP_UNUSED_C4FF = 0x1c4, OP_UNUSED_C5FF = 0x1c5, OP_UNUSED_C6FF = 0x1c6, OP_UNUSED_C7FF = 0x1c7, OP_UNUSED_C8FF = 0x1c8, OP_UNUSED_C9FF = 0x1c9, OP_UNUSED_CAFF = 0x1ca, OP_UNUSED_CBFF = 0x1cb, OP_UNUSED_CCFF = 0x1cc, OP_UNUSED_CDFF = 0x1cd, OP_UNUSED_CEFF = 0x1ce, OP_UNUSED_CFFF = 0x1cf, OP_UNUSED_D0FF = 0x1d0, OP_UNUSED_D1FF = 0x1d1, OP_UNUSED_D2FF = 0x1d2, OP_UNUSED_D3FF = 0x1d3, OP_UNUSED_D4FF = 0x1d4, OP_UNUSED_D5FF = 0x1d5, OP_UNUSED_D6FF = 0x1d6, OP_UNUSED_D7FF = 0x1d7, OP_UNUSED_D8FF = 0x1d8, OP_UNUSED_D9FF = 0x1d9, OP_UNUSED_DAFF = 0x1da, OP_UNUSED_DBFF = 0x1db, OP_UNUSED_DCFF = 0x1dc, OP_UNUSED_DDFF = 0x1dd, OP_UNUSED_DEFF = 0x1de, OP_UNUSED_DFFF = 0x1df, OP_UNUSED_E0FF = 0x1e0, OP_UNUSED_E1FF = 0x1e1, OP_UNUSED_E2FF = 0x1e2, OP_UNUSED_E3FF = 0x1e3, OP_UNUSED_E4FF = 0x1e4, OP_UNUSED_E5FF = 0x1e5, OP_UNUSED_E6FF = 0x1e6, OP_UNUSED_E7FF = 0x1e7, OP_UNUSED_E8FF = 0x1e8, OP_UNUSED_E9FF = 0x1e9, OP_UNUSED_EAFF = 0x1ea, OP_UNUSED_EBFF = 0x1eb, OP_UNUSED_ECFF = 0x1ec, OP_UNUSED_EDFF = 0x1ed, OP_UNUSED_EEFF = 0x1ee, OP_UNUSED_EFFF = 0x1ef, OP_UNUSED_F0FF = 0x1f0, OP_UNUSED_F1FF = 0x1f1, OP_INVOKE_OBJECT_INIT_JUMBO = 0x1f2, OP_IGET_VOLATILE_JUMBO = 0x1f3, OP_IGET_WIDE_VOLATILE_JUMBO = 0x1f4, OP_IGET_OBJECT_VOLATILE_JUMBO = 0x1f5, OP_IPUT_VOLATILE_JUMBO = 0x1f6, OP_IPUT_WIDE_VOLATILE_JUMBO = 0x1f7, OP_IPUT_OBJECT_VOLATILE_JUMBO = 0x1f8, OP_SGET_VOLATILE_JUMBO = 0x1f9, OP_SGET_WIDE_VOLATILE_JUMBO = 0x1fa, OP_SGET_OBJECT_VOLATILE_JUMBO = 0x1fb, OP_SPUT_VOLATILE_JUMBO = 0x1fc, OP_SPUT_WIDE_VOLATILE_JUMBO = 0x1fd, OP_SPUT_OBJECT_VOLATILE_JUMBO = 0x1fe, OP_THROW_VERIFICATION_ERROR_JUMBO = 0x1ff, // END(libdex-opcode-enum)&#125;Opcode; 3.2 指令格式标识指令格式的约定如下: ​ ● 指令格式标识大多由三个字符组成，前两个是数字，最后一个是字母​ ● 第一个数字是表示指令有多少个16位的字组成​ ● 第二个数字是表示指令最多使用寄存器的个数。特殊标记 “r” 标识使用一定范围内的寄存器。​ ● 第三个字母为类型码，表示指令用到的额外数据的类型。取值见如下表。 助记符 位大小 说 明 b 8 8位有符号立即数 c 16,32 常量池索引 f 16 接口常量（仅对静态链接格式有效） h 16 有符号立即数（32位或64位数的高值位，低值位为0） i 32 立即数，有符号整数或32位浮点数 l 64 立即数，有符号整数或64位双精度浮点数 m 16 方法常量（仅对静态链接格式有效） n 4 4位的立即数 s 16 短整型立即数 t 8, 16, 32 跳转，分支 x 0 无额外数据 注: 每条指令操作码只能有一个固定的指令格式标识 但多条指令操作码可能具备相同的指令格式标识 参考下图, 每条指令操作码的指令格式标识已经预定义好 ​ | Op &amp; Format | Mnemonic / Syntax | Arguments || ———– | ————————— | —————————————- || 00 10x | nop | || 01 12x | move vA, vB | A: destination register (4 bits)B: source register (4 bits) || 02 22x | move/from16 vAA, vBBBB | A: destination register (8 bits)B: source register (16 bits) || 03 32x | move/16 vAAAA, vBBBB | A: destination register (16 bits)B: source register (16 bits) || 04 12x | move-wide vA, vB | A: destination register pair (4 bits)B: source register pair (4 bits) || 05 22x | move-wide/from16 vAA, vBBBB | A: destination register pair (8 bits)B: source register pair (16 bits) || 06 32x | move-wide/16 vAAAA, vBBBB | A: destination register pair (16 bits)B: source register pair (16 bits) || … | … | … | 完整表格请查询文档 如: 01 操作码的指令标识是10x, 表示指令只有一个16位数、没有使用寄存器、无额外数据 Android 4.0 docs 另外还有一个指令格式表, 请查阅文档 3.3 使用以上表进行指令阅读加入通过分析某Dex文件,我们成功找到某块代码的二进制指令码如下: 162 00 00 00 1A 01 01 00 6E 20 02 00 10 00 0E 00 需要遵循的原则: 指令以ushort (16 bit)为指令长度单位 指令默认为小端格式 op 都是位于首个 16bit 数据的低 8 bit 以上二进制指令码我们可以翻译为16进制: 123456780x 00 620x 00 000x 01 1A0x 00 01 0x 20 6E0x 00 020x 00 100x 00 0E 通过这个，我们还不能判断出有多少条完整的指令, 按照指令格式进行解读: 利用原则【op 都是位于首个 16bit 数据的低 8 bit】我们找到第一条指令的OP为0x62 使用0x62在指令集表查到0x62的指令助记符为 sget-object，指令标识为21C, 且类型化操作为: sstaticop vAA, field@BBBB 再利用查询到的指令标识(21C) 在指令格式表中查询到指令格式为: | Format | ID | Syntax | Notable Opcodes Covered || ————- | —- | —————————————- | ———————————– || AA|op BBBB | 21c | op vAA, type@BBBB op vAA, field@BBBB op vAA, string@BBBB | check-cast const-class const-string | 此指令格式包含3类语法操作 结合第二点类型化(field)判断对应的操作和语法应为: AA|op BBBB / op vAA field@BBBB. 于是得到： 这条完整指令由两个16位指令组成的指令, 第一条指令的高8位含义为 vAA寄存器(值为0,即寄存器v0)，紧接着第二个16位BBBB(值为0x0000)表示field_ids 区里 Index = 0的东东. 指令含义为 - sget-object v0, field_ids[0] 再依次继续循环解析后续指令即可 3.4 小结解析指令的思路: 找到op 依据op查[指令集]表找到对应的&lt;指令标识&gt;和&lt;指令助记符&gt; 根据查到的op的&lt;指令标识&gt;在[指令格式表]查找指令op的完整指令格式 根据指令助记符和完整的指令格式，解析出op对应的完整指令语义 重复上述步骤 4. 尾巴需要继续理解的问题: android 4.0 扩展的 JUMBO 指令, 超出了一字节的范畴，怎么解析的？ 寄存器的v命名法和p命名法, 反编译的时候怎样指定使用哪种命名法？","categories":[{"name":"VM","slug":"VM","permalink":"https://nixlong.github.io/categories/VM/"}],"tags":[{"name":"dalvik","slug":"dalvik","permalink":"https://nixlong.github.io/tags/dalvik/"},{"name":"vm","slug":"vm","permalink":"https://nixlong.github.io/tags/vm/"},{"name":"smali","slug":"smali","permalink":"https://nixlong.github.io/tags/smali/"}]},{"title":"Hexo + Github搭建Blog","slug":"09-Tools/[0] - Hexo+github搭建Blog","date":"2017-09-30T04:00:00.000Z","updated":"2017-10-31T06:38:34.640Z","comments":true,"path":"2017/09/30/09-Tools/[0] - Hexo+github搭建Blog/","link":"","permalink":"https://nixlong.github.io/2017/09/30/09-Tools/[0] - Hexo+github搭建Blog/","excerpt":"","text":"Hexo + Github搭建Blog[TOC] 0. 前置条件 依赖npm，需要安装 Node.js 配置好Github Pages 安装Hexo Docs - npm install -g hexo-cli 1. 配置hexo1) 安装好hexo后, 选择一个目录作为hexo博客目录, 进行初始化, 本操作会向hexo仓库同步hexo代码并安装相关依赖: $ hexo init $ cd $ npm install 2) 2. 漂亮的hexo主题###2.1 Next link : https://github.com/iissnan/hexo-theme-next ###2.2 Icarus link : https://github.com/ppoffice/hexo-theme-icarus 3. 常用目录命令12345hexo cleanhexo g / generatehexo s / serverhexo s -p porthexo d / deploy 4. 常见问题###4.1 hexo获取Tags失败解决 使用 hexo new page 新建一个页面，命名为 tags ： $ cd your-hexo-site$ hexo new page tags 编辑刚新建的页面，设置type为tags： 1234title: 标签date: 2014-12-22 12:39:04type: &quot;tags&quot;--- 在主题配置文件中，在menu项下，要把tags页打开如menu:1234567home: / categories: /categories #about: /about archives: /archives tags: /tags //确保标签页已打开 #schedule: /schedule #commonweal: /404.html ###4.2 hexo s 浏览器没有响应可能是默认4000端口被占用, 更换 hexo s -p xxxx 端口 4.3 给文章增加Banner图片和缩略图 开启配置 thumbnail : true 在md开始配置 banner: url 和 thumbnail: url 可参考: 点我 ​ ###4.4 hexo g 异常 YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 7, column 7: ​ 在 key: value 之间, 必须存在空格","categories":[{"name":"TOOL","slug":"TOOL","permalink":"https://nixlong.github.io/categories/TOOL/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://nixlong.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://nixlong.github.io/tags/github/"}]},{"title":"Ymodem协议移植","slug":"04-Mcu/[mcu] - Ymodem协议移植","date":"2017-08-14T04:00:00.000Z","updated":"2017-10-31T06:38:34.640Z","comments":true,"path":"2017/08/14/04-Mcu/[mcu] - Ymodem协议移植/","link":"","permalink":"https://nixlong.github.io/2017/08/14/04-Mcu/[mcu] - Ymodem协议移植/","excerpt":"#Ymodem协议移植 [TOC] STM32/Dvm项目移植FatFS时,使用W25Qxx Flash做文件系统,不能使用USB或其他外设接口直接进行文件拷贝, 因此移植Ymodem协议用于向Flash下载文件. ##0.Ymodem介绍 Ymodem在嵌入式项目中,常用于文件下载和IAP在线编程.Ymodem协议是一种发送并等待的协议。即发送方发送一个数据包以后，都要等待接收方的确认，分为Ymodem-1K和Ymodem-G两种子格式.","text":"#Ymodem协议移植 [TOC] STM32/Dvm项目移植FatFS时,使用W25Qxx Flash做文件系统,不能使用USB或其他外设接口直接进行文件拷贝, 因此移植Ymodem协议用于向Flash下载文件. ##0.Ymodem介绍 Ymodem在嵌入式项目中,常用于文件下载和IAP在线编程.Ymodem协议是一种发送并等待的协议。即发送方发送一个数据包以后，都要等待接收方的确认，分为Ymodem-1K和Ymodem-G两种子格式. YModem-1K用1024字节信息块传输取代标准的128字节传输，数据的发送回使用CRC校验，保证数据传输的正确性。它每传输一个信息块数据时，就会等待接收端回应ACK信号，接收到回应后，才会继续传输下一个信息块，保证数据已经全部接收。 YModem-g传输形式与YModem-1K差不多，但是它去掉了数据的CRC校验码，同时在发送完一个数据块信息后，它不会等待接收端的ACK信号，而直接传输下一个数据块。正是它没有涉及错误校验，才使得它的传输速度比YModem-1K来得块。 一般情况使用YModem-1K传输，而平时所说的YModem也是指的是YModem-1k. ##1. Ymodem的协议格式 传输信号定义: 1.0 帧格式1START CC ~CC Data[128]:[1024] CRCH CRCL 一个Ymodem数据帧由帧头(START CC ~CC)、数据体和帧尾三部分构成:12341) START : 如果是SOH，表示这帧数据体长度为128 Bytes; 为STX, 标识这帧数据体长度为1024 Bytes.(总长恒为128+5 或者1024+5)2) CC : 表示帧序号, 从0开始增加,超过255后，又从0开始计数3) ~CC为: CC的反码. 一起进行帧序的有效性判断4) CRCH/CRCL分别为CRC16校验的高低字节, 校验多项式定义为: CRC16-CCITT/x16+x12+x5+1. CRC只针对数据体计算,不包含帧头 ###1.1 传输起始帧 1SOH 00 FF filename 00 filezise 00 NUL[00] CRCH CRCL 传输起始帧以SOH信号开始,数据体长度128 序号为0,数据体已filename开始,为ascii码格式字符串,然后紧跟00表示文件名结束;之后紧跟filesize,将每位转换为16进制的ascii码,后续到数据体结尾完全补00。如文件名123.c 长度 1024字节(0x400), 那么在数据体的格式为: 31 32 33 2E 63 00 34 30 30 00 … 后续用00 补充 filename和filesize构成最长不超过128字节 ###1.2 数据帧 1SIG CC ~CC Data[128]:[1024] &lt;1A...&gt; CRCH CRCL 在实际传输中, 数据帧根据文件大小不同分多种情况处理。假设文件大小为X.M=X/1024,N=X%1024.因为Ymodem-1K只有128和1024两种数据帧大小: 如果M大于0:那么这M帧按照每帧1024字节传输,SIG为信号STX 如果N大于128小于1024:SIG为STX,这帧按照1024字节传输,不足1024字节部分使用 1A 补全 如果N小于等于128:SIG为SOH，这帧按照128字节传输，不足128字节使用1A补全 ###1.3 结束帧 1SOH 00 FF 128x[00] CRCH CRCL 结束帧类似起始帧，序号为00, 但数据体为空(全0x00). ###1.4 要点 帧长恒为133(SOH开始)或1029(STX开始)之一 起始/结束帧序号一定为0x00(反码0xff) 数据帧序号从1开始计数, 但超过255后,会从0开始重新计数 发送方实际发送的数据size是大于等于实际文件大小的, 接收方善用filesize和1A进行实际size接收 ##2. Ymodem的传输过程 1234567891. 接收方发送信号C启动传输会话,然后进入等待（SOH）状态，如果没有回应，就会超时退出2. 发送方开始时处于等待C过程中。收到C以后，发送携带文件名和文件长度的起始帧（SOH）数据包开始信号。进入等待（ACK）状态3. 接收方收到SOH起始帧以后，CRC校验满足，则发送ACK。发送方接收到ACK，又进入等待“文件传输开启”信号，即重新进入等待“C”的状态4. 接收方发送C,表示可以开始数据的传输5. 于是发送方发送数据帧、接收方接收到后回复ACK，如此循环进行数据接收(过程中双方因为任何异常,如人工终端、通讯故障等都可能造成传输中断).6. 文件传输完毕后，发送方发送EOT信号，接收方收到后，回应NAK7. 发送方再次发送EOT，接收方回应ACK。8. 接收方发送C，准备再次文件传输9. 如果是单次文件传输，发送方发送传输结束帧，接收方回应ACK后，整个传输会话结束 ##3. Ymodem向STM32的移植 这里没有根据Ymodem协议进行全新实现，而是选用了ST官方 STM32F0xx_IAP demo的一个Ymodem实现进行修改移植. 它原本用于IAP的, 这里修改为即可适用普通文件传输也可以用于IAP. 3.1. 原ST代码下载 原代码在对filesize处理时存在bug，将最后一帧多余的1A也认作文件内容了3.2. 重构代码为两部分：ANSI-C部分和Porting移植层，ANSI-C部分可以方便移植到各个平台，而只需要重新实现Porting层的接口即可3.3 重构后的目录结构:12src: 为ANSI-C部分, 方便向各平台移植inc: porting头文件，包含需要移植实现的接口函数 3.4 接口函数12345678910111213141516/********************************************************* * The Porting APIs Should Be Implemented ********************************************************/extern unsigned int SerialKeyPressed(unsigned char *key);extern void SerialPutChar(unsigned char c);extern unsigned char SerialReadByte(void);extern void ymodem_init(void);extern unsigned int ymodem_get_receive_maxsize(void);extern unsigned int ymodem_get_transmit_size(void);//0 - success ; -1 - failextern int ymodem_recv_start_cb(const char * filename, const unsigned int filesize);extern int ymodem_recv_processing_cb(const unsigned char * buffer, const unsigned int buff_size);extern int ymodem_recv_end_cb(void); 3.5 在项目的接口实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224/* Private typedef -----------------------------------------------------------*//* Private define ------------------------------------------------------------*//* Private macro -------------------------------------------------------------*//* Private variables ---------------------------------------------------------*//* Private function prototypes -----------------------------------------------*//* Private functions ---------------------------------------------------------*//******************************************************************************** * Porting APIs ********************************************************************************/typedef enum&#123; TRANS_FILE = 0, IAP_IMAGE = 1,&#125;YMODEM_ACTION_E;typedef struct&#123; COMM_TYPE_E ymodem_uart; YMODEM_ACTION_E ymodem_action; uint32_t ymodem_receive_supported_maxsize; uint32_t ymodem_transmit_size; bool_t ymodem_file_inited; uint32_t ymodem_file_total_size; uint32_t ymodem_file_handled_size; FIL ymodem_file_handle; uint8_t ymodem_file_tmppath[FF_MAX_LFN];&#125;YMODEM_DATA_T;STATIC YMODEM_DATA_T s_ymodem_data;PUBLIC void ymodem_init(void)&#123; memset(&amp;s_ymodem_data, 0, sizeof(YMODEM_DATA_T)); s_ymodem_data.ymodem_uart = COM1; comm_enable_rxit(s_ymodem_data.ymodem_uart); s_ymodem_data.ymodem_action = TRANS_FILE; switch(s_ymodem_data.ymodem_action)&#123; case TRANS_FILE: s_ymodem_data.ymodem_receive_supported_maxsize = 1024 * 1024 *5; s_ymodem_data.ymodem_transmit_size = 0; break; case IAP_IMAGE: #warning \"MUST implement GOT transmit SIZE!\" s_ymodem_data.ymodem_receive_supported_maxsize = 1024 * 1024 *5; s_ymodem_data.ymodem_transmit_size = 0; break; default: //Not supported break; &#125;&#125;PUBLIC uint32_t ymodem_get_receive_maxsize(void)&#123; return s_ymodem_data.ymodem_receive_supported_maxsize;&#125;PUBLIC uint32_t ymodem_get_transmit_size(void)&#123; return s_ymodem_data.ymodem_transmit_size;&#125;//0 - success ; -1 - failPUBLIC int ymodem_recv_start_cb(const char * filename, const uint32_t filesize)&#123; FRESULT fres; const char * prefix = (const char*)\"1:/\"; char *filepath = (char*)&amp;s_ymodem_data.ymodem_file_tmppath[0]; uint32_t filepath_size = sizeof(s_ymodem_data.ymodem_file_tmppath); switch(s_ymodem_data.ymodem_action)&#123; case TRANS_FILE: if(strlen(prefix) + strlen((char*)filename) &gt;= filepath_size)&#123; return -1; //path length too long &#125; memset(&amp;s_ymodem_data.ymodem_file_tmppath[0], 0, filepath_size); filepath = strcat((char*)filepath, prefix); filepath = strcat((char*)filepath, (char*)filename); if(FR_OK != (fres = f_open (&amp;s_ymodem_data.ymodem_file_handle, filepath, FA_WRITE | FA_CREATE_ALWAYS)))&#123; logd(\"Ymodem Start: create file(%s) fail(%d)...\\n\", filepath, fres); return -1; &#125; else &#123; logd(\"Ymodem Start: create file(%s) ok(%d)...\\n\", filepath, fres); s_ymodem_data.ymodem_file_inited = TRUE; s_ymodem_data.ymodem_file_total_size = filesize; s_ymodem_data.ymodem_file_handled_size = 0; return 0; &#125; //break; case IAP_IMAGE: /* erase user application area */ //FLASH_If_Erase(APPLICATION_ADDRESS); break; default: //Not supported break; &#125; return -1;&#125;PUBLIC int ymodem_recv_processing_cb(const uint8_t * buffer, const uint32_t buff_size)&#123; FRESULT fres; uint32_t to_write_size = 0; uint32_t writted_size = 0; uint32_t order = 0; switch(s_ymodem_data.ymodem_action)&#123; case TRANS_FILE: to_write_size = s_ymodem_data.ymodem_file_total_size - s_ymodem_data.ymodem_file_handled_size; to_write_size = (buff_size &gt; to_write_size) ? to_write_size : buff_size; order = (uint32_t)buffer - 2; if(FR_OK != (fres = f_write(&amp;s_ymodem_data.ymodem_file_handle, buffer, to_write_size, &amp;writted_size)))&#123; logw(\"Ymodem process(%d): write file(%d - %d) fail(%d)...\\n\", *((uint8_t*)order), to_write_size, writted_size, fres); return -1; &#125; else &#123; s_ymodem_data.ymodem_file_handled_size += to_write_size; logi(\"Ymodem process(%d): write file(%d/%d) ok(%d)...\\n\", *((uint8_t*)order), s_ymodem_data.ymodem_file_handled_size, s_ymodem_data.ymodem_file_total_size, fres); return 0; &#125; //break; case IAP_IMAGE: //if (FLASH_If_Write(&amp;flashdestination, (uint32_t*) ramsource, (uint16_t) packet_length/4) == 0) break; default: //Not supported break; &#125; return -1;&#125;PUBLIC int ymodem_recv_end_cb(void)&#123; FRESULT fres; FILINFO fno; switch(s_ymodem_data.ymodem_action)&#123; case TRANS_FILE: if(TRUE != s_ymodem_data.ymodem_file_inited) return -1; fres = f_close(&amp;s_ymodem_data.ymodem_file_handle); logd(\"Ymodem End: close file res(%d)...\\n\", fres); fres = f_stat((const TCHAR *)s_ymodem_data.ymodem_file_tmppath, &amp;fno); if(fres != RES_OK)&#123; logw(\"Get File Status Fail(%d)...\\n\", fres); &#125; else &#123; logi(\"Get File Status ok(%d), file size(%d) Bytes...\\n\", fres, fno.fsize); &#125; memset(&amp;s_ymodem_data.ymodem_file_handle, 0, sizeof(FIL)); memset(&amp;s_ymodem_data.ymodem_file_tmppath[0], 0, sizeof(s_ymodem_data.ymodem_file_tmppath)); s_ymodem_data.ymodem_file_total_size = 0; s_ymodem_data.ymodem_file_handled_size = 0; s_ymodem_data.ymodem_file_inited = FALSE; return 0; //break; case IAP_IMAGE: /* erase user application area */ //FLASH_If_Erase(APPLICATION_ADDRESS); break; default: //Not supported break; &#125; return -1;&#125;/** * @brief Test to see if a key has been pressed on the HyperTerminal * @param key: The key pressed * @retval 1: Correct * 0: Error */uint32_t SerialKeyPressed(uint8_t *key)&#123; uint8_t err; uint8_t ret; //wait 10ms at most ret = comm_read_char(s_ymodem_data.ymodem_uart, 2, &amp;err); if(COMM_NO_ERR == err)&#123; *key = ret; return 1; &#125; else &#123; return 0; &#125;&#125;//fail - 0xff; success -other valueuint8_t SerialReadByte(void)&#123; uint8_t err; uint8_t ret; //wait 10ms at most ret = comm_read_char(s_ymodem_data.ymodem_uart, 10, &amp;err); if(COMM_NO_ERR == err)&#123; return ret; &#125; else &#123; return 0xff; &#125;&#125;/** * @brief Print a character on the HyperTerminal * @param c: The character to be printed * @retval None */void SerialPutChar(uint8_t c)&#123; comm_send_char(s_ymodem_data.ymodem_uart, c, 10); &#125; 参考: YModem协议简介","categories":[{"name":"MCU","slug":"MCU","permalink":"https://nixlong.github.io/categories/MCU/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://nixlong.github.io/tags/STM32/"},{"name":"Ymodem","slug":"Ymodem","permalink":"https://nixlong.github.io/tags/Ymodem/"}]},{"title":"STM32内存结构总结","slug":"04-Mcu/[mcu] - STM32内存结构总结","date":"2017-08-04T04:00:00.000Z","updated":"2017-10-31T06:38:34.625Z","comments":true,"path":"2017/08/04/04-Mcu/[mcu] - STM32内存结构总结/","link":"","permalink":"https://nixlong.github.io/2017/08/04/04-Mcu/[mcu] - STM32内存结构总结/","excerpt":"#STM32内存结构总结 [TOC] ##0.STM32内存结构图 ##1.要点 ###1.1 两种存储类型: RAM 和 Flash RAM可读可写，在STM32的内存结构上，RAM地址段分布[0x2000_0000, 0x2000_0000 + RAM size) Flash只读，在STM32的内存结构上，Flash地址段[0x0800_0000, 0x2000_0000)","text":"#STM32内存结构总结 [TOC] ##0.STM32内存结构图 ##1.要点 ###1.1 两种存储类型: RAM 和 Flash RAM可读可写，在STM32的内存结构上，RAM地址段分布[0x2000_0000, 0x2000_0000 + RAM size) Flash只读，在STM32的内存结构上，Flash地址段[0x0800_0000, 0x2000_0000) ###1.2 六类存储数据段: .data/.bss/.text/.constdata/heap/stack .data数据段: 用来存放初始化了但不是初始化为0的全局变量(global)和静态变量（static）。它是可读可写的 .bss(Block Started by Symbol)数据段: 用于存放没有初始化或初始化为0的全局变量和静态变量，可读可写，如果没有初始化, 系统会将变量初始化为0. .text代码段: 用来放程序代码（code）， 在代码编译完成后, 长久只读存放于此. .constdata只读常量数据段: const限定的数据类型存放与此，只读. heap堆区: 通常只我们说的动态内存分配,使用内存分配器(memory allocator)管理, malloc/free进行申请和释放 stack栈区: 在代码执行时用来保存函数的局部变量和参数。其操作方式类似于数据结构中的栈，是一种“后进先出”（Last In First Out，LIFO）的数据结构。这意味着最后放到栈上的数据，将会是第一个从栈上移走的数据，对于哪些暂时存储的信息，和不需要长时间保存的信息来说，LIFO这种数据结构非常理想。在调用函数或过程后，系统通常会清除栈上保存的局部变量、函数调用信息及其它信息。栈的顶部通常在可读写的RAM区的最后，其地址空间通常“向下减少”，即当栈上保存的数据越多，栈的地址就越小。 ###1.3 三种存储属性区: RO/RW/ZI RO (Read Only ): 只读区域, 需要长久保存，烧写到Rom/Flash段,上文数据段的.text段和.constdata段属于此属性区(有时.constdata 段也被叫做 RO-data段, 和这个广义的RO注意区分) RW (Read Write): 可读可写的初始化了的全局变量和静态变量段，上文中的.data段属于RW区 ZI (Zero Init): 没有进行初始化或者初始化为0，系统上电时会主动把此区域数据进行0初始化，上文的.bss段就是. 另外, 可翻看Keil工具编译的map文件，Heap和Stack区也进行了Zero的属性标注, 因此， Heap和Stack也可认为是ZI区域 RW区比较特别, 可读可写但又进行了初始化,因为RAM中的数据是掉电不可保存的，因此RW区的.data段数据也需要保存在Rom/Flash里面，上电时候再将此类数据复制到RAM区域读写使用。而ZI区域数据不需要掉电保存，直接上电时初始化为0即可使用，因此不需要保存在ROM中。这样，计算RAM/ROM占用空间的公式: ROM Size = .text + .constdata + .data (RO + RW)RAM Size = .bss + .data (ZI + RW) 这里RAM size计算时未考虑Stack和Heap区, 实际size是大于此的， 因为这两个区域具备动态变化的复杂性，难于估计。 定义一个全局数组变量举例:1231. static unsigned char test[1024]; //全局、未初始化, ZI区,不影响ROM size2. static unsigned char test[1024] = &#123;0&#125;; //全局、初始化为0, ZI区,不影响ROM size3. static unsigned char test[1024] = &#123;1&#125;; //全局、初始化为非0, RW(.data)区,ROM Size 扩大 ###1.4 扩展说说Heap12在STM32的启动代码startup_*.s文件中,一般这样定义了堆大小：Heap_Size EQU 0x200; 在实际使用中, 这个区域可能比1.2节提到的简洁描述更为复杂。 很多小项目没有使用内存分配器: 由于各种原因(RAM不足、程序简单、etc)，一些所必须的大块或固定内存直接使用数组的方式定义使用,绕开了内存分配器。那么这个时候, Heap_Size 的存在是没有意义的, Heap_Size 定义越大，越浪费空间，可以直接Heap_Size定义为0。这个时候, 本来该堆区提供的空间可能定义在了.bss段(全局/静态数组没有初始化)、或.data(全局/静态数据初始化为非0)、或Stack上(使用了局部数组变量, Tips: 但大的数组不建议定义在stack, 否则可能栈溢出) 重新实现内存分配器：没有直接将内存分配器直接映射在堆区，而是先定义大的数组内存(可能在.bss或.data, 为避免在ROM存储, 最好在.bss)， 再将这块内存给内存分配器支配使用 内存分配器直接使用Heap区: 这个时候就要计算好预留多少空间给Stack区, 留多了，Stack用不上浪费；留少了极可能造成Stack溢出而程序崩溃 除了使用自带RAM外，同时使用外部扩展RAM: 这就需要内存分配器来管理好几块地址不连续的RAM空间了 ##2.小结 Author - nix.longDate - 2017.08.04","categories":[{"name":"MCU","slug":"MCU","permalink":"https://nixlong.github.io/categories/MCU/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://nixlong.github.io/tags/STM32/"},{"name":"STACK","slug":"STACK","permalink":"https://nixlong.github.io/tags/STACK/"},{"name":"Heap","slug":"Heap","permalink":"https://nixlong.github.io/tags/Heap/"}]},{"title":"Iot网络层无线技术方案PK(2) - LPWAN的王者之争[NB-IOT pk Lora]","slug":"03-Iot/[iot] - Iot网络层无线技术方案PK(2) - 华山论剑Round 1 - LPWAN的王者之争 - NB-IOT pk Lora","date":"2017-07-26T04:00:00.000Z","updated":"2017-10-31T06:38:34.625Z","comments":true,"path":"2017/07/26/03-Iot/[iot] - Iot网络层无线技术方案PK(2) - 华山论剑Round 1 - LPWAN的王者之争 - NB-IOT pk Lora/","link":"","permalink":"https://nixlong.github.io/2017/07/26/03-Iot/[iot] - Iot网络层无线技术方案PK(2) - 华山论剑Round 1 - LPWAN的王者之争 - NB-IOT pk Lora/","excerpt":"#Iot网络层无线技术方案PK(2) - LPWAN的王者之争[NB-IOT pk Lora] [TOC] 续接上篇: Iot网络层无线技术方案PK(1) - 技术特点初探 3.1 华山论剑Round 1: LPWAN的王者之争 - NB-IOT pk Lora低功耗广域网应用典型的场景条件是: a. 终端节点无法或者很难提供市政电源供电, 需要使用电池设备 b. 终端节点的数据上下行频次非常低 c. 终端节点的数量可能非常多 d. 终端节点之间的距离或者终端节点安装位置距离数据中心可能相距非常远 回到上文的两中网络结构中, LPWAN方案就是从终端到云端典型的一层网络结构。上文的场景条件我们假设用其他方案实现:","text":"#Iot网络层无线技术方案PK(2) - LPWAN的王者之争[NB-IOT pk Lora] [TOC] 续接上篇: Iot网络层无线技术方案PK(1) - 技术特点初探 3.1 华山论剑Round 1: LPWAN的王者之争 - NB-IOT pk Lora低功耗广域网应用典型的场景条件是: a. 终端节点无法或者很难提供市政电源供电, 需要使用电池设备 b. 终端节点的数据上下行频次非常低 c. 终端节点的数量可能非常多 d. 终端节点之间的距离或者终端节点安装位置距离数据中心可能相距非常远 回到上文的两中网络结构中, LPWAN方案就是从终端到云端典型的一层网络结构。上文的场景条件我们假设用其他方案实现: 如果此类场景都通过有线布线来实现，那么实现方案是灾难性的。 在LPWAN技术成熟之前，由于Zigbee具有低功耗和路由两个特征，且修改条件d为满足这样的条件: 节点之间的距离相距不远且环境容易接入其他广域网络. 这样的小部分场景就让Zigbee + 网关转换的两层网络结构蚕食。 如果修改条件a能提供电源供电, 那么现成的2/3/4G网络就能撸袖子开干(前提也是信号能到达). 所有条件都不能修改？ 好了， 现在LPWAN下众神归位，上帝的归该还给上帝了… NB-IOT和Lora有极其相似的技术规范特征和设计目的, 一个为3GPP所生,一个由Lora联盟在养. 他们生来就是相同应用领域的竞争关系, 全球范围内, 领地都各有斩获, 但在国内，情况大有不同: 所有运营商都在推NB-IOT. 而只有部分企业在局部范围内建设Lora网络用于试点或者给出Lora网络建设方案等待买家. 假设在国内最终的结果和目前状况一样：NB-IOT全歼三大运营商、Lora被三大运营商通通抛弃。那么Lora是否该提前在中国市场唱响挽歌呢？ 我们先不急于下结论，先来看看GSMA研究报告给LPWAN定义的7大类应用领域：农业、环境、消费品及医疗、工业、物流、智能楼宇以及智慧城市/公共事业。 农业：农业应用（养殖及土地监测、禽畜跟踪） 环境：环境监测（污染、噪声、雨、云、河水流速、健康危害等的数据采集和实时监控） 消费品及医疗：可穿戴，家用电器，VIP跟踪（动物或小孩），智能自行车，辅助生活，临床远程监控 工业：设备状态，工厂控制、处理以及安全监控 物流：工业资产，集装箱跟踪(位置及状态更新) 智能楼宇：报警系统，制动器，空调系统，接入控制 公共事业：天然气以及水计量，配水网络监控，微型发电 顺便说说, 目前如火如荼的共享单车市场, 就是LPWAN大展伸手的好战场. 我们再从几个方面对比和推测一下: 国内的政府和运营商支持：NB-IOT完胜, Lora完败 Lora目前的系统架构是LoraWAN，一种异步的基于ALOHA的协议，节点可以根据具体应用场景需求进行或长或短的睡眠，三种模式Class A/B/C, 其中 Class A 具备最低功耗的工作模式；而NB-IOT基于蜂窝网络构建，蜂窝网络同步协议的节点基于Qos服务质量的考虑必须定期地联网。从侧面造成 NB-IOT 实际应用中不可能如Lora省电。究竟差异多大暂时还没有这方便的对比.. 成本对比：版权成本 - Lora的版权成本远低于NB-IOT；硬件成本 - LoraWAN协议比NB-IOT简单，外围电路开发成本低于NB-IOT；使用成本 - Lora需要自己搭建网关或基站，第一次投入成本大，NB-IOT基站由运营商搭建，但每月租金成本是持续的，如果节点规模很大, 那么Lora可以摊薄成本，而NB-IOT成本累积就很可观了；维护成本 - Lora需要一并维护终端节点和网关，NB-IOT自行维护终端节点，基站由运营商负责 场景限制： 现在我们再看LPWAN7大类应用领域，如果场景是偏远山村的农业，偏远地区的工业或环境检测。这个时候NB-IOT就要看运营商是否把建站建设到祖国的每一寸河山了，否则自行架设几十平方公里的Lora网络再接入广域网，也怕是个不错的补充选择. 数据安全性：Lora自行架设不经过运营商的手，反而可能会被某些数据安全要求高的行业和公司所看重，可使用Lora方案架设自己的私有网络 跑马圈地的速度：Lora已经迭代出成熟的节点、网关、基站产品；而NB-IOT大部分地区还在试点和初步商用阶段，等到全国基站升级完成，可能会是后年马月。那么这段时间内Lora可能圈住一小部分地盘，然后由于技术更换成本高，将这小部分地盘占据一长段时间 基于现目前的条件推断： 在不远的将来，蛋糕大部分必定是被NB-IOT所切分，Lora可能在细分市场、局部地区和特种行业分到一点稀粥。但是还有一点甚为重要：LPWAN产品并不会在使用电源后就不能更好的工作，尤其在国内的Lora由一个广域网协议简直使用成一个局域网协议的情况下，那么他们可能会去抢占其他老牌技术的地盘，比如数传、比如Zigbee1PK结果预测: 在国内，NB-IOT会坐稳LPWAN领域的头把交椅, Lora分到小块份额，但不至于凄唱挽歌. 至于LPWAN的其他几个儿子, 国内暂未听什么打雷声, 距离下雨就远啦 Author： nix.longDate : 2017.07.26整理撰写，禁止转载； 错误之处，敬谢斧正.","categories":[{"name":"IOT","slug":"IOT","permalink":"https://nixlong.github.io/categories/IOT/"}],"tags":[{"name":"Iot","slug":"Iot","permalink":"https://nixlong.github.io/tags/Iot/"},{"name":"NB-IOT","slug":"NB-IOT","permalink":"https://nixlong.github.io/tags/NB-IOT/"},{"name":"Lora","slug":"Lora","permalink":"https://nixlong.github.io/tags/Lora/"}]},{"title":"Iot网络层无线技术方案PK(1) - 技术特点初探","slug":"03-Iot/[iot] - Iot网络层无线技术方案PK(1) - 技术特点初探","date":"2017-07-25T04:00:00.000Z","updated":"2017-10-31T06:38:34.625Z","comments":true,"path":"2017/07/25/03-Iot/[iot] - Iot网络层无线技术方案PK(1) - 技术特点初探/","link":"","permalink":"https://nixlong.github.io/2017/07/25/03-Iot/[iot] - Iot网络层无线技术方案PK(1) - 技术特点初探/","excerpt":"#Iot网络层无线技术方案PK(1) - 技术特点初探 [TOC] 0.引言 物联网领域典型的3层结构划分为: 感知层 网络层 应用层 (细粒度可进一步划分为服务层和应用层) 感知层是数据的来源, 应用层是数据的分析展现. 网络层是钮合感知层和应用层的重要数据通路.目前网络层的成熟方案有各种有线、无线方式或组合方式。本文主要讨论几个用于物联网网络层的无线技术","text":"#Iot网络层无线技术方案PK(1) - 技术特点初探 [TOC] 0.引言 物联网领域典型的3层结构划分为: 感知层 网络层 应用层 (细粒度可进一步划分为服务层和应用层) 感知层是数据的来源, 应用层是数据的分析展现. 网络层是钮合感知层和应用层的重要数据通路.目前网络层的成熟方案有各种有线、无线方式或组合方式。本文主要讨论几个用于物联网网络层的无线技术 1.网络层技术方案总览 根据不同的应用场景, 可以使用两类网络结构来完成物联网组网. 单层网络结构:如果应用场景终端点数极少或者终端点距离极远, 可以直接使用点通过互联网接入云的网络结构, 这里的网络接入解决方案可以是有线的以太网、无线的wifi(*参见说明1)、 或者运营商的2/3/4/5G网络、SMS短消息甚至急趋于成熟的nb-iot 两层网络结构:如果应用场景终端点数较多或终端点需要相互通讯,就需要采用双层网络结构组网, 其中两层网络中间的纽带就是物联网网关(不同应用场景有不同叫法).网关向上负责广域网的接入, 网关向下负责局域网各终端节点的管理,并进一步实现实现两层网络的转换和进行数据转发. 根据不同应用场景, 广域网的技术方案可以是以太网、Wifi ( 参见说明1)、2/3/4/5G 等(此类模式绝大多数场景中SMS、NB-IOT不适合作为广域网出口). 局域网技术方案可以使用MODBUS等成熟的老牌有线通讯协议, 也可以从Wifi( 参见说明1)、 BLE(低功耗蓝牙技术)、ZigBee、Z-Wave、Lora(* 见说明2)等无线技术方案中选择 要点: 使用有线连接技术进行组网，可选用的广域网接入方式有以太网,局域网组网方式有以太网、MODBUS等 使用无线连接技术进行组网，可选用的广域网接入方式有Wifi、NB-IOT，而局域网可选择的方式有Wifi、BLE、Zigbee、Z-Wave、Lora(* 见说明2)等 说明: Wifi[无线保真]属于WLAN(无线局域网)的技术之一，是局域网联网解决方案, 但是实际使用中,Wifi AP通过有线宽带或者2/3/4G运营商网络直接接入广域网后. 那么接入此AP的WIFI STA也直接具备广域网访问能力. 因此这里我们视WIFI既能做为局域网组网方案、也能作为广域网接入方案. 关于Lora和NB-IOT 补充一点: 本身这两种协议都属于LPWAN(低功耗广域网) 方案！ 是的, 他们设计初衷是直接作为广域网接入协议的. 但是由于国内运营商都主推NB-IOT能进行广域网接入, 而对于工作于非授权频段的Lora还没有任何表示(国外有部分运营商在推), 国内用户需要自行搭建基站/网关来进行广域网接入. 在一些小型的lora使用场景里, Lora网关是需要通过协议转换才能接入广域网，因此针对目前国内状况，本文就暂且将Lora归入局域网组网方案；而将NB-IOT视为广域网接入方案. 接下来主要比较 Wifi、Bluetooth(蓝牙)、ZigBee、Z-Wave、Lora、NB-IOT 几类无线通信技术的特点和典型应用场景12备注: 无线通信技术非常多, 为何本文只选这几种对比? 缘由前4类(Wifi/蓝牙/Zigbee/Z-Wave) 在近年的家居物联网领域采用相对广泛, 而Lora/NB-IOT又在中国的LPWAN应用领域上位之争争得不亦乐乎, 就让人容易忽略掉LPWAN的诸如sigfox的其他几个儿子... 2.撩开你的面纱 - 各家技术特点初探 2.1 Wifi典型特点 基于IEEE 802.11, 支持广域网/局域网接入 / 2.4G ISM频段 带宽高、传输速率很快(&gt;10MB/s)、普及率高 中近距离通讯、接入较慢、无线稳定性相对较差 有限的网络容量, 接入能力非常有限(常低于16个接入点的水平) 相对功耗较高 数据加密型安全等级相对较低, 容易暴力破解 成本: 具备专利费, 目前费用已较低 ​ 2.2 蓝牙典型特点 蓝牙技术联盟, 局域网协议 / 2.4G ISM频段 很近距离通讯(典型值 &lt; 10米), 较低的功耗、通信速率中快(1MB/s级别) 非常有限的接入容量(典型值 &lt; 8), 常用于一对一配对访问场景 功耗：较低 数据安全性: 较低 成本: 较低 2.3 Zigbee典型特点 基于IEEE802.15.4标准的局域网协议 / 2.4G ISM频段 近距离、低复杂度、自组网(多种组网方案)、低功耗、低数据速率(最大250KB/s)、低成本 很大的网络容量, 理论最大可以到65000 带有中继路由功能, 此功能可以用于远距离扩展和信号阻挡时跳跃 安全等级: AES-128加密，高 成本: 免专利费, 芯片加外围电路. 较低 2.4 Z-Wave典型特点 Zensys公司开发/Z-wave联盟, 暂未进入IEEE标准 / 局域网协议 工作频段: 908.42MHz(美国)~868.42MHz(欧洲)，此频段在国内属于非民用频段 低成本、低功耗、高可靠、短距离(典型值30米) 低传输速率(9.6k bps) 中等网络容量(目前最大232个节点, 大于蓝牙、Wifi, 小于zigbee) 安全等级: 无加密 2.5 Lora典型特点 Lora联盟, 设计为广域网接入, 实际国内暂不受运营商待见.需要自己架设网关, 实际用成了局域网 工作频段: 非授权 远距离、超低功耗, 电池供电典型寿命能达到10年 低速数据传输, 网络容量非常大 有支持星型网络的LoraWAN系统协议结构设计, 也可进行mesh组网实现,但会损失低功耗特性 2.6 NB-IOT典型特点 3GPP，复用运营商蜂窝网络. 国内运营商大力发展，但网络覆盖还在试点区域 远距离、超低功耗， 电池供电典型寿命能达到10年 低速数据传输, 网络容量非常大 2.7 问?1. 从上各技术特点可以看出, Wifi、蓝牙、ZigBee都工作在2.4G ISM 频段, 真是不花钱的ISM频段大法好啊, 这也造成一个困扰: 工作在同一个信号空间时的相互频段干扰...得想法好好解决... 2. Z-Wave咋看有点相似ZigBee，似乎是ZigBee的一个子集版本, 随着竞争的剧烈, 那么谁是六耳猕猴，谁又是能取真经的孙悟空呢? 3. Lora和NB-IOT真的除了爹妈不一样, 简直就是双胞胎, 技术特征极其相似. 在国内的LPWAN域, 最后谁会练就铁砂掌的裘千仞，谁又会是招摇撞骗的裘千丈呢? Think:对比了几类无线传输技术的技术特点, 各个技术都有自己的个性特征, 但某些技术相互之间又有些看似重合的特点导致存在明显的竞争关系, 在在实际场景中该怎么选用呢？ 3. 华山论剑之/PK在实际应用中，方案选择总会参照几个要点: 方案成本、速率、数据安全性、网络稳定性和网络容量、功耗和传输距离 等. 然后综合选择一个解决方案… 华山论剑，近了… Author： nix.longDate : 2017.07.25整理撰写，禁止转载； 错误之处，敬谢斧正.","categories":[{"name":"IOT","slug":"IOT","permalink":"https://nixlong.github.io/categories/IOT/"}],"tags":[{"name":"iot","slug":"iot","permalink":"https://nixlong.github.io/tags/iot/"},{"name":"nb-iot","slug":"nb-iot","permalink":"https://nixlong.github.io/tags/nb-iot/"},{"name":"lora","slug":"lora","permalink":"https://nixlong.github.io/tags/lora/"},{"name":"wifi","slug":"wifi","permalink":"https://nixlong.github.io/tags/wifi/"},{"name":"zigbee","slug":"zigbee","permalink":"https://nixlong.github.io/tags/zigbee/"}]},{"title":"Iot基础案例设计初览","slug":"03-Iot/[iot] - Iot基础案例设计初览","date":"2017-07-24T04:00:00.000Z","updated":"2017-10-31T06:38:34.609Z","comments":true,"path":"2017/07/24/03-Iot/[iot] - Iot基础案例设计初览/","link":"","permalink":"https://nixlong.github.io/2017/07/24/03-Iot/[iot] - Iot基础案例设计初览/","excerpt":"Iot基础案例设计初览[TOC]0.Index Internet Of Things - 万物联网。 互联网是人与人的网络互联来产生价值, 而物联网目的是能将任何物体的任何属性都能接入网络或进行反向控制(交互控制和智能控制), 有价值的立刻产生价值, 没有价值的进行价值创造. 1. 物联网要义要义: 物联网的基础要义是远程数据获取和远程对象控制 远程获取数据和远程对象控制既为满足既有需求，又为创造产生新价值 获得的数据需要存储、分析使用和展示呈现；控制要处理发起点和执行点 现在的技术手段都围绕数据、远程、和展示/控制三大部分展开. 来提高其稳定性、安全性、增强智能化以及降低成本 于是很显然的, 物联网典型的三层结构呼之欲出: 感知层 [对应数据获取 和 控制执行点] 网络层 [对应解决远程的问题] 应用层 (细粒度可进一步划分为服务层和应用层) [对应解决数据的存储、使用和展现及控制发起点]","text":"Iot基础案例设计初览[TOC]0.Index Internet Of Things - 万物联网。 互联网是人与人的网络互联来产生价值, 而物联网目的是能将任何物体的任何属性都能接入网络或进行反向控制(交互控制和智能控制), 有价值的立刻产生价值, 没有价值的进行价值创造. 1. 物联网要义要义: 物联网的基础要义是远程数据获取和远程对象控制 远程获取数据和远程对象控制既为满足既有需求，又为创造产生新价值 获得的数据需要存储、分析使用和展示呈现；控制要处理发起点和执行点 现在的技术手段都围绕数据、远程、和展示/控制三大部分展开. 来提高其稳定性、安全性、增强智能化以及降低成本 于是很显然的, 物联网典型的三层结构呼之欲出: 感知层 [对应数据获取 和 控制执行点] 网络层 [对应解决远程的问题] 应用层 (细粒度可进一步划分为服务层和应用层) [对应解决数据的存储、使用和展现及控制发起点] 不同应用场景的可能的演进过程: 进行数据获取和人机交互性的数据下行 进行数据获取和人机交互性的数据下行和控制下行 进行数据获取，加入AI和各种算法服务，完成下行控制的智能化、自动化 远程可以通过互联网加各种局域的有线/无线协议来进行技术实现, 对于获取数据和远程控制, 只有基于安全才会有实用意义. 这里的安全包括但不仅限于: 数据获取、传输和存储的加密性安全；数据不遗失的稳定性安全；涉及用户的隐私性数据安全；涉及远程控制的高安全可靠性. 但在目前行业的一片喧嚣声中, 安全性可能是最被忽略和置后考虑的. 根据行业的差异性，物联网又涉及到几个大的细分领域：工业物联(4.0重要方向), 家居物联, 车联网以及农业、环境、城市公共事业等 由于安全性的顾虑, 目前家居物连外的其他方向, 远程控制的发展极为缓慢的. 唯在家居物连方向，由于远程控制涉及的安全性不为特别突出, 一些典型的远程控制场景在这个领域诞生, 比如**的家居产品系列. 当然，如果突然遇到家里接入网络的LED灯忽明忽暗，也不要感到恐怖。只是可能你的家居网络被黑客攻破后逗你玩玩而已. 这里使用家居物联而非智能家居这个词的原因是: 联网只是初级门槛, 而智慧还要涉及更多的工作 本文先主要谈谈三层结构的网络层, 感知层和应用层涉及技术在以后的设计案例中介绍 2. 远程[网络层]技术实现举例 本章节提到的各种无线技术特点不深解析点到为止，会另开文进行比较 ###2.0 案例索引 我们假设一个简洁的家居场景来作为案例索引，本文后面说明都主以此例为例: &gt; 某软硬件都懂点的码农小X拥有一客厅两卧室一厨一卫一种花养猫小阳台的温馨小居, 拟进行初级的家居物联改造，产品不买现成的，技术自己实现: 接入客厅门禁感应器D1 - 检测开关门情况 接入分布在客厅, 主卧，次卧的三盏LED灯控制器(分别标记为L1,L2,L3) - 实现远程开关灯操作和开关状态检测 接入客厅的空调控制器A1 - 实现远程开关客厅空调 接入厨房的带开关控制的煤气检测仪B1 - 实现煤气漏气检测和远程操作关闭煤气装置 接入厨房的火警传感器F1 - 实现检测火警报警 接入阳台花园的浇水控制器装置W1 - 实现远程控制给花园植物浇水 以上远程操作需要可以在任何地方进行 必然目前方案的技术实现基于目前成熟的联网技术和协议. 远程的控制终端可以是app或网页或微信等.码农小X可以选用两个思路的技术方案: 单层网络结构：远程分别单独读取或控制D1, L1,L2,L3,A1,B1,F1,W1 双层网络结构：设计一个中继转发设备C, 所有的读取或控制都经过C进行转发 ###2.1 物联网的单层网络结构方案 拓扑示意如上图的下半部分 设计要点是直接使用现成的广域网数据接入协议, 针对每个单点对象进行访问控制.那么每个目标设备都需要直接接入广域互联网.目前可直接接入互联网的方案有: 2G/3G/4G/Wifi/有线宽带/SMS, 以及运营商正在扩建的LPWAN网络…这个方案的特点: 每个设备都是独立的接入广域网, 相互之间不关心其他设备的存在 每个设备都需要搭载一套广域网接入解决方案 假设小X选用这种网络方案来完成他的家居物联改造：这种方案除了每个终端节点都能复用现在的居家标配以太网或者Wifi以外，其他任何直连广域网方案都会产生额外的费用，这一定是小X代表的群体大多数所不愿意的。好了，以太网还是Wifi呢？ 以太网: 如果所有终端都用有线以太网接入，想象一下小X满屋都是网线的情况，而且安装好后还不能随便移动。帮小X pass Wifi - 至少是个很不错的方案了呢，每个产品节点至少都能入网了。BUT… 1.只是由于Wifi功耗问题，得要求每个产品节点都要设计供电电源，并把电源布线到家里每个角落，方便随时可以挪挪； 2.由于Wifi网络容量的问题，小X以后也别扩展太多产品节点了，加上家里的各种电脑、pad、phone，Wifi热点实在受不住这么多连接点啊，多了，连不上？不稳定？老要重启路由器？ 看样子在小X的改造方案里, 广域网使用以太网是各馊主意，用Wifi算是个好方案，但好像由于功耗和负载能力问题，还不算最理想的方案啊! ###2.2 物联网的两层网络结构方案 拓扑示意如上图的上半部分 以网关C为界: 向上接入标准广域网使用2/3/4G、以太网或接入以太网的Wifi 向下使用各类方案进行组网或者混合组网完成局域网组建, 如wifi、zigbee、蓝牙、z-wave等 这样，网络层的数据通道就成了： 数据下行时：数据先走到网关C，再通过C 转发 到目标终端节点 数据上行时：终端节点将数据上报给网关C，再由C转发到Server 继续为小X的改造方案出谋划策： Wifi的特点前面已经讨论 小X看了一下自己屋子平面图，看了一下蓝牙目前的技术特性(容量小、距离短)，暂时忽略了蓝牙方案 剩下ZigBee和Z-Wave，小X网上学习了下咋看有点相似的两协议，对比了下技术特点后再在某宝对比了下模块供应量和价格，决定先考虑Zigbee(ZigBee较低功耗的特点可以对某些节点设计电池供电，妈妈再也不会担心满屋都是乱飞的电源线啦) 到这里，小X对他的方案有个初步草稿了 ###2.3 小X的方案设计初稿 对比了单层网络结构和两层网络结构后，小X决定采用两层网络结构且广域网基于Wifi技术局域网基于Zigbee技术来给出设计方案初稿： 因为Zigbee不具备广域网接入能力，那么设计一个中继器网关: 作为广域网和局域网的协议和数据转的换换点；作为Zigbee网络系统的协调器角色 给门禁节点D1, LED灯L1,L2,L3, 空调控制器A1,煤气检测仪B1,火警检测F1,浇水装置W1 都加上Zigbee终端节点用于数据/控制上下行 一并给出小X设计的各模块检测/控制技术：D1检测开关状态量、L1/2/3 用继电器加PWM技术、A1涉及红外、B1/F1采购现成的传感器、W1得整个小水泵. ###2.4 小X的新烦恼 在小X将他的计划绘声绘色的讲给家人听后，大家都听懂了，大家都觉得好，大家对小X表达了支持后，大家顺便又提出了新想法： 老婆： 咱上班又遇上爸妈回老家的时候，阳台上养的小猫咪贝拉没人喂食啊，要不顺便设计一个带视频的远程喂食系统，在办公室就能喂，多方便啊！ 什么？买一个现成的？你可是傲娇的公城狮诶，不该说这种话吧？！对了，卧室几年没用的蓝牙音箱，你也往你的系统里面给设计设计呀。能随时给贝拉放歌呢 儿子：爸爸爸爸、你这么厉害，给我设计一个可以手机上控制的遥控飞机好不好？买？我不要买的，满大街都是，一点都不酷.. 老妈：儿子，孙子一天喜欢小区到处乱跑，到饭点了还老不回家，你给他设计一个手上带的玩意，我在家里手机上就可以看到他在哪玩，还有我家里拿个对讲机一喊，他就听到回家啦，你说多好啊！柯南？谁是柯南？ 老爸：儿子，你知道我心脏有点小问题，每天总有那么一两下跳动好像不规律，能不能想个办法给我监测下？上医院？上医院干什么，我不是看那网上都吹什么 爱 技术要取代医生了吗，哦，你这个技术不是爱技术啊！那你现学啊… 唉… 小 X 心想，想装个逼，把自己给装进去了… ##3. 方案技术框架 小X设计方案的典型三层物联网拓扑框架图： 初步考虑好了整个框架，涉及到更多的技术细节需要考虑： 1234561. 网络层的广域网络选用什么IP协议来连接服务器和网关, 基于TCP？UDP？甚至HTTP？还是基于新贵MQTT或COAP？2. 网络层的广域网选用不同的IP协议，让网关层、应用层需要产生哪些额外的工作，变得更复杂还是更简单？3. 网络层的局域网络初步设计为Zigbee星形网络，是否要提前考虑未来接入其他非Zigbee终端，怎么预留，怎么考虑？4. 局域网络的数据协议怎么定义？5. 应用层的数据接入、数据存储、数据分析使用、数据展示怎么来设计，使用什么技术或框架？6. 感知/终端层涉及到上行的数据/状态采集，也涉及到下行的状态检测和控制输出，也需要配合应用层和网络层来考虑协议制定7. 感知/终端层涉及到各种硬件协议和技术，将来在小X的案例进行中慢慢解析 可以看出，整个方案不同层次之间相互影响，比如终端只能提供很有限的硬件存储资源和运算能力，使用json格式甚至xml这些常用于web开发的数据格式，而对于很多嵌入式设备来说简直就是什么鬼？！ 每层设计得为其他层考虑，不能只图本层自己爽. ##4. 演进 小Y：我不是小X啊，只是懂些上层开发技术，下层这些东西，我只能玩玩Arduino吗，好像arduino现在赚钱的就只是arduino开发板本身啊！树莓派？做产品价格略贵技术略复杂啊… 小Z：我不是小X啊，只是懂些下层嵌入式技术，上层的web、app开发通通不会，怎么玩啊！ 小X：我是小X，物联网三层各懂一点，但我做的这些技术设计，好像换一个应用场景又要全来一次啊，有没有部分技术可以复用的呢，尽量重用硬件设计、尽量能重用软件设计，或者设计一种方便跨越几种无线通信技术的框架啊？ 由于场景需求的多样性，软硬件技术的多样性，即使都期待一种更通用的框架技术，也是走的步履蹒跚。高通推的Alljoyn，在试图做这个尝试，有兴趣的小X, 小Y，小Z可以关注Alljoyn的发展。 ##5. 结束 小X的家居物联改造方案，本次先出个框框，后面慢慢跟小X一起进行技术实现了。 用一个简单的设计案例简单的描述了物联网的三层技术结构，提到几个简单的行业常见词语。物联网是一个大的行业，不仅仅是一个专业，有多种应用场景和多类典型的应用领域。前文提到的单层网络结构和提到的LPWAN技术，只是在小X的案例中没有应用到，在其他更多更广阔的领域里，都在发挥着巨大的作用。 感知终端层涉及的更多软硬件(及各类传感器)技术，网络层的有线无线局域广域方案、应用层的ABCD等，都在各种场景里面进行着排列组合，尽量设计出最优方案来解决各种场景问题。优秀的方案特点必定包含但不限于：简洁的技术实现、稳定而又安全、尽量低的成本、更方便的运行维护。 下次再聊别的，也关于IOT！ Author: nix.long原创撰写，禁止转载； 错误之处，敬谢大刀斧正.","categories":[{"name":"IOT","slug":"IOT","permalink":"https://nixlong.github.io/categories/IOT/"}],"tags":[{"name":"iot","slug":"iot","permalink":"https://nixlong.github.io/tags/iot/"}]}]}